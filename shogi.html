<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>the Shogi(æ¥µã¿å°†æ£‹) H.M.C</title>
  <link rel="stylesheet" href="./assets/css/shogi.css?v=20260117-2">

  <script>
    window.AI_HTTP = "https://samurairoad-ws.korokorokororintyo.workers.dev";
  </script>
  <style>
    /* --- Mobile menu (minimal) --- */
    #mobileMenuBtn{display:none;position:fixed;right:12px;bottom:12px;z-index:9999}
    #mobileMenuBtn .btn{padding:.8rem 1rem;border-radius:999px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    #mobileDrawer{display:none;position:fixed;inset:0;z-index:9998;background:rgba(0,0,0,.55)}
    #mobileDrawer .panel{position:absolute;right:0;top:0;height:100%;width:min(92vw,420px);background:rgba(17,26,51,.98);border-left:1px solid rgba(255,255,255,.12);padding:12px;overflow:auto}
    #mobileDrawer .tabs{display:flex;gap:8px;align-items:center;margin-bottom:10px}
    #mobileDrawer .tabs .btn{flex:1}
    #mobileDrawer .closeBtn{flex:0 0 auto}
    #mobileDrawer .drawerSection{display:none}
    #mobileDrawer .drawerSection.active{display:block}
    #settingsPanel .row{margin-top:8px}
    /*
      Mobile detection:
      - width based (<=1100px) for small tablets
      - pointer based for smartphones even if CSS px is large (DPR issues)
    */
    @media (max-width: 1100px){
      #mobileMenuBtn{display:block}
    }
    @media (hover: none) and (pointer: coarse){
      #mobileMenuBtn{display:block}
    }
  

    /* ensure kifu panel is visible inside drawer on mobile */
    #mobileDrawer #kifuPanel{display:block !important;margin:0 !important;width:100% !important;max-width:none !important;}
    #mobileDrawer #kifuPanel .row{flex-wrap:wrap}
    #mobileDrawer #kifuPanel textarea{min-height:180px;}
</style>


  <style>
    /* --- UX: larger board on mobile + last move highlight --- */
    .cell.lastFrom{ box-shadow: inset 0 0 0 3px rgba(255,255,255,.55); }
    .cell.lastTo{ box-shadow: inset 0 0 0 3px rgba(122,162,255,.95); }
    /* If both match, prioritize 'to' */
    .cell.lastFrom.lastTo{ box-shadow: inset 0 0 0 3px rgba(122,162,255,.95), inset 0 0 0 6px rgba(255,255,255,.35); }

    @media (max-width: 980px){
      /* reduce card padding a bit to give the board more real estate */
      #gamePanel{ padding:10px !important; }
      /* force the board to use viewport width */
      #board{
        width: min(96vw, 560px);
        aspect-ratio: 1 / 1;
        margin: 0 auto;
        display: grid;
        grid-template-columns: repeat(9, 1fr);
        grid-template-rows: repeat(9, 1fr);
      }
      /* make cells stretch with the board */
      #board .cell{
        width: auto !important;
        height: auto !important;
      }
      #board .piece{
        font-size: clamp(18px, 4.8vw, 28px);
      }
      #board .coord{
        font-size: clamp(9px, 2.2vw, 12px);
      }
    }
  </style>

</head>
<body>

  <!-- Mobile Menu -->
  <div id="mobileMenuBtn"><button class="btn primary" type="button">ãƒ¡ãƒ‹ãƒ¥ãƒ¼</button></div>
  <div id="mobileDrawer" aria-hidden="true">
    <div class="panel">
      <div class="tabs">
        <button class="btn" id="tabSettings" type="button">è¨­å®š</button>
        <button class="btn" id="tabKifu" type="button">æ£‹è­œ</button>
        <a class="btn" id="tabHelp" href="./shogihelp.html" target="_blank" rel="noopener">ãƒ˜ãƒ«ãƒ—</a>
        <button class="btn ghost closeBtn" id="btnDrawerClose" type="button">Ã—</button>
      </div>

      <div id="drawerSettings" class="drawerSection">
        <div class="card" id="settingsPanel">
          <h1>è¨­å®š</h1>
          <div class="muted" style="margin-bottom:8px">ã‚¹ãƒãƒ›ã®åˆ¶é™ã«ã‚ˆã‚Šã€éŸ³ã¯æœ€åˆã®ã‚¿ãƒƒãƒ—å¾Œã«æœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚</div>
          <div class="row">
            <label class="small" style="display:flex;align-items:center;gap:8px">
              <input type="checkbox" id="chkAudio" checked> éŸ³ï¼šON
            </label>
          </div>
          <div class="row">
            <label class="small" style="display:flex;align-items:center;gap:8px">
              <input type="checkbox" id="chkVibe" checked> æŒ¯å‹•ï¼šON
            </label>
          </div>
        </div>
      </div>

      <div id="drawerKifu" class="drawerSection">
        <div id="drawerKifuHost"></div>
      </div>
    </div>
  </div>

  
  <!-- UI Modal (no browser alert/confirm) -->
  <div id="uiModal" style="display:none;position:fixed;inset:0;z-index:10000;background:rgba(0,0,0,.6)">
    <div style="max-width:520px;margin:12vh auto 0;background:rgba(17,26,51,.98);border:1px solid rgba(255,255,255,.14);border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.45);padding:14px 14px 12px">
      <div id="uiModalMsg" style="line-height:1.7"></div>
      <div class="row" style="margin-top:12px;justify-content:flex-end;gap:8px">
        <button class="btn ghost" id="uiModalCancel" type="button" style="display:none">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button class="btn primary" id="uiModalOk" type="button">OK</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <section class="card" id="gamePanel">
      <h1>æ¥µã¿å°†æ£‹</h1>
      <p class="muted">
        URLã® <code>#room=xxxx</code> ã‚’å…±æœ‰ã™ã‚‹ã¨åŒã˜éƒ¨å±‹ã«å…¥ã‚Œã¾ã™ã€‚<br>
      </p>

      <div class="row" style="margin:10px 0">
        <input id="name" class="input" style="max-width:220px" placeholder="åå‰" />
        <button class="btn primary" id="btnConnect">æ¥ç¶š</button>
        <button class="btn" id="btnCopyUrl">éƒ¨å±‹ã‚³ãƒ”ãƒ¼</button>
        <button class="btn" id="btnReset">ãƒªã‚»ãƒƒãƒˆ</button>
        <button class="btn" id="btnFull">â›¶ å…¨ç”»é¢</button>
        <button class="btn chatToggle" id="btnChatToggle">ğŸ’¬ ãƒãƒ£ãƒƒãƒˆ</button>
        <button class="btn ghost" id="btnSound">ğŸ”Š éŸ³: ON</button>
      </div>
<div class="status" id="status">æœªæ¥ç¶š</div>

      <div class="row" style="margin:10px 0 12px">
        <span class="badge turnBig" id="turnBadge"><span class="dot"></span><span id="turnText">æ‰‹ç•ª: -</span></span>
      </div>


<div class="hand">
            <div class="handTitle"><span>å¾Œæ‰‹ã®æŒã¡é§’</span><span class="small" id="handHintG"></span></div>
            <div class="handPieces" id="handG"></div>
          </div>

      <div style="margin-top:12px">
        <div id="board" aria-label="shogi-board"></div>

        <div class="hands">
          
          <div class="hand">
            <div class="handTitle"><span>å…ˆæ‰‹ã®æŒã¡é§’</span><span class="small" id="handHintS"></span></div>
            <div class="handPieces" id="handS"></div>
          </div>
        </div>

        <div class="hint">
          ãƒ»æŒã¡é§’ã¯ <b>è‡ªåˆ†ã®æ‰‹ç•ª</b>ã®ã¨ãã ã‘é¸ã¹ã¾ã™ï¼ˆé¸æŠâ†’ç›¤ã®ç©ºãƒã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã§æ‰“ã¤ï¼‰ã€‚<br>
          ãƒ»ç›¤ã®é§’ã‚’é¸æŠâ†’ç§»å‹•å…ˆã‚¯ãƒªãƒƒã‚¯ã§å‹•ã‹ã—ã¾ã™ã€‚<br>
        </div>
      </div>
    </section>

    
    <div id="kifuDock"></div>
    <aside class="card" id="kifuPanel">
      <h1>æ£‹è­œ</h1>
      <div class="muted" style="margin-bottom:8px">
        ã€Œå‰ã¸/æ¬¡ã¸ã€ã§æ‰‹é †å†ç”Ÿï¼ˆãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰ã§ãã¾ã™ã€‚
      </div>

      <div class="row" style="margin-top:6px">
        <button class="btn" id="btnKifuDelete">æ£‹è­œãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤</button>
        <button class="btn ghost" id="btnKifuImport">æ£‹è­œãƒ•ã‚¡ã‚¤ãƒ«èª­è¾¼</button>
        <button class="btn primary" id="btnAiReview">ğŸ¤– AIå¯¾å±€è©•ä¾¡</button>
      </div>

      <div class="row" style="margin-top:10px">
        <button class="btn" id="btnKifuPrev">å‰ã¸</button>
        <button class="btn" id="btnKifuNext">æ¬¡ã¸</button>
        <span class="small" id="kifuStep">æ‰‹æ•° 0 / 0</span>
      </div>

      <div class="row" style="margin-top:10px">
        <textarea id="kifuText" class="input" style="min-height:140px;resize:vertical" placeholder="ã“ã“ã«æ£‹è­œJSONã‚’è²¼ã‚Šä»˜ã‘ï¼ˆã‚¤ãƒ³ãƒãƒ¼ãƒˆç”¨ï¼‰"></textarea>
      </div>
      <p class="small"></p>
    </aside>


    <aside class="card">
      <h1>ãƒãƒ£ãƒƒãƒˆ</h1>
      <div class="chatLog" id="chatLog"></div>
      <div class="chatComposer">
      <div class="row" style="margin-top:0">
        <input id="chatInput" class="input" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸â€¦" />
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn primary" id="btnSend">é€ä¿¡</button>
      </div>
      </div>
      <p class="small">â€»è¦³æˆ¦è€…ã‚‚ãƒãƒ£ãƒƒãƒˆå¯èƒ½ã€‚å¯¾å±€ã¯å…ˆç€2äººãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãªã‚Šã¾ã™ï¼ˆMVPã®ãŸã‚å¼·åˆ¶ã¯æœªå®Ÿè£…ï¼‰ã€‚</p>
    </aside>

    <aside class="card" id="devMemo">
      <h1>é–‹ç™ºè€…ãƒ¡ãƒ¢</h1>
      <div class="muted" style="font-size:.92rem;line-height:1.65">
        <div>MVPï¼šåˆæ³•æ‰‹ãƒ»ç‹æ‰‹åˆ¤å®šãƒ»æ‰“ã¡æ­©è©°ã‚ç­‰ã¯æœªå¯¾å¿œï¼ˆãŸã ã—ã€ŒäºŒæ­©ã€ã€Œè¡Œãæ‰€ã®ãªã„é§’ã®æ‰“ã¡ã€ã¯æœ€ä½é™ã‚¬ãƒ¼ãƒ‰ï¼‰ã€‚</div>
        <div>æˆã‚Šã¯å®Ÿè£…æ¸ˆã¿ï¼ˆæˆã‚Œã‚‹å ´åˆã¯ç¢ºèªã€å¼·åˆ¶æˆã‚Šã‚‚å¯¾å¿œï¼‰ã€‚</div>
        <div>ãƒ»æŒã¡é§’ã¯ <b>è‡ªåˆ†ã®æ‰‹ç•ª</b>ã®ã¨ãã ã‘é¸ã¹ã¾ã™ï¼ˆé¸æŠâ†’ç›¤ã®ç©ºãƒã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã§æ‰“ã¤ï¼‰ã€‚</div>
        <div>ãƒ»ç›¤ã®é§’ã‚’é¸æŠâ†’ç§»å‹•å…ˆã‚¯ãƒªãƒƒã‚¯ã§å‹•ã‹ã—ã¾ã™ã€‚</div>
        <div>ãƒ»ç‹ãŒå–ã‚‰ã‚ŒãŸã‚‰å‹æ•—è¡¨ç¤ºï¼ˆãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—è¡¨ç¤ºï¼‰ã€‚</div>
        <div>ãƒ»é€šä¿¡åŸºç›¤ã¯å¤‰æ›´ãªã—ï¼ˆWorker/DOã¯ä¸­ç¶™ãƒ»åŒæœŸãƒ»ä¿å­˜ã®ã¿ï¼‰ã€‚</div>
        <div>ãƒ»AIã«ã‚ˆã‚‹æ¬¡ã®æœ€å–„æ‰‹è§£æï¼ˆè¨­è¨ˆæ¡ˆï¼‰ï¼šã¾ãšã¯ã€Œç¾å±€é¢ã‚’ãƒ†ã‚­ã‚¹ãƒˆåŒ–â†’è§£æç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆâ†’ã‚³ãƒ”ãƒ¼ã—ã¦AIã«è²¼ã‚‹ã€æ–¹å¼ï¼ˆè¶…å®‰å…¨ï¼‰ã€‚æ¬¡æ®µéšã§WorkersçµŒç”±ã®APIé€£æºã€ã•ã‚‰ã«å°†æ£‹ã‚¨ãƒ³ã‚¸ãƒ³/WASMåŒ–ã¸æ‹¡å¼µã€‚</div>
        <div>ãƒ»æ£‹è­œï¼šè‡ªå‹•å–å¾—ONã®ã¨ãã€æŒ‡ã—æ‰‹ã”ã¨ã«ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ï¼ˆlocalStorageï¼‰ã—ã¾ã™ã€‚</div>
      </div>
    </aside>

  </div>
<div class="small" style="margin-top:14px;text-align:right;opacity:.85">
        Â© hisa.miya
      </div>
</div>


<div id="aiResultModal" style="display:none;position:fixed;inset:0;z-index:10001;background:rgba(0,0,0,.65);padding:8px">
  <div class="ai-content" style="max-width:860px;margin:6vh auto 0;background:rgba(17,26,51,.98);border:1px solid rgba(255,255,255,.14);border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.45);padding:16px;max-height:86vh;overflow:auto">
    <div id="aiResultBody"></div>
    <div class="row" style="justify-content:flex-end; margin-top:20px;">
      <button class="btn" onclick="document.getElementById('aiResultModal').style.display='none'">é–‰ã˜ã‚‹</button>
    </div>
  </div>
</div>

<script>
(() => {
  // Workerï¼ˆâ€»ãƒ‘ã‚¹ã¯ä¾é ¼ãŒãªã„é™ã‚Šå¤‰æ›´ã—ãªã„ï¼‰
  const WORKER_WS = "wss://samurairoad-ws.korokorokororintyo.workers.dev";

  // DOM
  const boardEl  = document.getElementById("board");
  const statusEl = document.getElementById("status");
  const nameEl   = document.getElementById("name");
  const btnConnect = document.getElementById("btnConnect");
  const btnCopyUrl = document.getElementById("btnCopyUrl");
  const btnReset = document.getElementById("btnReset");
  const btnFull = document.getElementById("btnFull");

  // ---- UI Modal (replace browser alert/confirm to avoid site/title display) ----
  const uiModal = document.getElementById("uiModal");
  const uiModalMsg = document.getElementById("uiModalMsg");
  const uiModalOk = document.getElementById("uiModalOk");
  const uiModalCancel = document.getElementById("uiModalCancel");

  function uiAlert(message){
    return new Promise((resolve)=>{
      if (!uiModal) { window.alert(message); resolve(); return; }
      uiModalMsg.textContent = message;
      uiModalCancel.style.display = "none";
      uiModalOk.textContent = "OK";
      uiModal.style.display = "block";
      const done = ()=>{ uiModal.style.display="none"; cleanup(); resolve(); };
      const onOk = ()=>done();
      const onBg = (e)=>{ if(e.target===uiModal) done(); };
      function cleanup(){
        uiModalOk.removeEventListener("click", onOk);
        uiModal.removeEventListener("click", onBg);
      }
      uiModalOk.addEventListener("click", onOk);
      uiModal.addEventListener("click", onBg);
    });
  }

  function uiConfirm(message, okText="OK", cancelText="ã‚­ãƒ£ãƒ³ã‚»ãƒ«"){
    return new Promise((resolve)=>{
      if (!uiModal) { resolve(window.confirm(message)); return; }
      uiModalMsg.textContent = message;
      uiModalCancel.style.display = "inline-flex";
      uiModalOk.textContent = okText;
      uiModalCancel.textContent = cancelText;
      uiModal.style.display = "block";
      const done = (v)=>{ uiModal.style.display="none"; cleanup(); resolve(v); };
      const onOk = ()=>done(true);
      const onCancel = ()=>done(false);
      const onBg = (e)=>{ if(e.target===uiModal) done(false); };
      function cleanup(){
        uiModalOk.removeEventListener("click", onOk);
        uiModalCancel.removeEventListener("click", onCancel);
        uiModal.removeEventListener("click", onBg);
      }
      uiModalOk.addEventListener("click", onOk);
      uiModalCancel.addEventListener("click", onCancel);
      uiModal.addEventListener("click", onBg);
    });
  }

  // expose modal helpers globally (used by later scripts)
  window.uiAlert = uiAlert;
  window.uiConfirm = uiConfirm;

  const btnChatToggle = document.getElementById("btnChatToggle");
  const chatLog = document.getElementById("chatLog");
  const chatInput = document.getElementById("chatInput");
  const btnSend = document.getElementById("btnSend");
  const btnSound = document.getElementById("btnSound");
  const turnText = document.getElementById("turnText");
  const handS = document.getElementById("handS");
  const handG = document.getElementById("handG");
  const handHintS = document.getElementById("handHintS");
  const handHintG = document.getElementById("handHintG");

  // KIFU control buttons
  const btnKifuDelete  = document.getElementById("btnKifuDelete");

  // Client ID cache (for role assignment)
  let clientId = null;
  try{
    clientId = localStorage.getItem("shogi_client_id");
    if (!clientId){
      clientId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : ("cid_" + Math.random().toString(16).slice(2) + Date.now());
      localStorage.setItem("shogi_client_id", clientId);
    }
  }catch{
    clientId = "cid_" + Math.random().toString(16).slice(2) + Date.now();
  }

  // Name cache
  try{
    const cached = localStorage.getItem("shogi_name");
    if (cached && !nameEl.value) nameEl.value = cached;
  }catch{}


  // é§’è¡¨è¨˜ï¼ˆå¤§æ–‡å­—=å…ˆæ‰‹ / å°æ–‡å­—=å¾Œæ‰‹ / "+X"=æˆã‚Šï¼‰
  const PIECE = {
    L:"é¦™",N:"æ¡‚",S:"éŠ€",G:"é‡‘",K:"ç‰",R:"é£›",B:"è§’",P:"æ­©",
    l:"é¦™",n:"æ¡‚",s:"éŠ€",g:"é‡‘",k:"ç‹",r:"é£›",b:"è§’",p:"æ­©",
    "+P":"ã¨","+p":"ã¨",
    "+L":"æˆé¦™","+l":"æˆé¦™",
    "+N":"æˆæ¡‚","+n":"æˆæ¡‚",
    "+S":"æˆéŠ€","+s":"æˆéŠ€",
    "+B":"é¦¬","+b":"é¦¬",
    "+R":"é¾","+r":"é¾"
  };

  const HAND_ORDER = ["R","B","G","S","N","L","P"];
  const HAND_LABEL = { R:"é£›",B:"è§’",G:"é‡‘",S:"éŠ€",N:"æ¡‚",L:"é¦™",P:"æ­©" };

  function basePiece(p){ return (typeof p === "string" && p.startsWith("+")) ? p.slice(1) : p; }
  function isPromoted(p){ return (typeof p === "string" && p.startsWith("+")); }
  function isSente(p){ const b = basePiece(p); return b && b === b.toUpperCase(); }
  function isGote(p){ const b = basePiece(p); return b && b === b.toLowerCase(); }
  function toSide(piece){ return isSente(piece) ? "S" : "G"; }

  function normalizeHands(g){
    if (!g.hands) g.hands = { S: {}, G: {} };
    if (!g.hands.S) g.hands.S = {};
    if (!g.hands.G) g.hands.G = {};
    return g;
  }

  function normalizeRoles(g){
    if (!g.roles) g.roles = { S: null, G: null };
    if (!("S" in g.roles)) g.roles.S = null;
    if (!("G" in g.roles)) g.roles.G = null;
    return g;
  }

  function initialGame(){
    return normalizeHands({
      turn:"S",
      board:[
        ["l","n","s","g","k","g","s","n","l"],
        [null,"r",null,null,null,null,null,"b",null],
        ["p","p","p","p","p","p","p","p","p"],
        [null,null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null,null],
        ["P","P","P","P","P","P","P","P","P"],
        [null,"B",null,null,null,null,null,"R",null],
        ["L","N","S","G","K","G","S","N","L"],
      ],
      hands: { S: {}, G: {} },
      roles: { S: null, G: null }
    });
  }

  let ws = null;
  let gotState = false;
  let game = ensureGameId(ensureKifu(normalizeRoles(initialGame())));
  // expose for other script blocks (module scope isolation)
  window.__KIWAMI_GAME = game;
  let selected = null;         // {r,c}
  let selectedDrop = null;     // {side,type}
  let lastMove = null;         // {from:{r,c}, to:{r,c}}
  let moverSide = null;         // æ‰‹ã‚’æŒ‡ã—ãŸå´ï¼ˆå¤šé‡å®£è¨€é˜²æ­¢ï¼‰
  // ---- æ£‹è­œï¼ˆJSONï¼‰ ----
  function ensureKifu(g){
    if (!g.kifu) g.kifu = { version: 1, initial: "standard", moves: [], cursor: 0 };
    if (!Array.isArray(g.kifu.moves)) g.kifu.moves = [];
    if (typeof g.kifu.cursor !== "number") g.kifu.cursor = g.kifu.moves.length;
    return g;
  }

  // ---- æ£‹è­œ è‡ªå‹•å–å¾—ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ï¼‰ ----
  let kifuAutoEnabled = false;
  let suppressAutoLoadOnce = false; // resetç­‰ã§ãƒ­ãƒ¼ã‚«ãƒ«è‡ªå‹•èª­è¾¼ã‚’ä¸€åº¦ã ã‘æŠ‘æ­¢
  let didAutoLoadKifu = false; // æ¥ç¶šæ™‚ã®è‡ªå‹•èª­è¾¼ã¯ä¸€åº¦ã ã‘

    // ---- å¯¾å±€IDï¼ˆè©¦åˆã”ã¨ã«æ£‹è­œã‚’åˆ†ã‘ã¦ä¿å­˜ï¼‰ ----
  function ensureGameId(g){
    if (!g.gameId){
      g.gameId = `g_${Date.now()}_${Math.random().toString(16).slice(2)}`;
      g.startedAt = new Date().toISOString();
      g.finishedAt = null;
      g.result = null;
    }
    return g;
  }

  function kifuIndexKey(){
    return `kiwami_kifu_index_v1:${currentRoom()}`;
  }

  function upsertGameIndex(meta){
    try{
      const key = kifuIndexKey();
      const arr = JSON.parse(localStorage.getItem(key) || "[]");
      const i = arr.findIndex(x => x.gameId === meta.gameId);
      if (i >= 0) arr[i] = { ...arr[i], ...meta };
      else arr.unshift(meta);
      localStorage.setItem(key, JSON.stringify(arr.slice(0, 50))); // 50è©¦åˆã¾ã§
    }catch{}
  }

  function finalizeCurrentGame(reason){
    try{
      ensureKifu(game);
      ensureGameId(game);
      // 0æ‰‹ã®å¯¾å±€ã¯ä¿å­˜ã—ãªã„ï¼ˆèª¤ãƒªã‚»ãƒƒãƒˆç­‰ã®ãƒã‚¤ã‚ºé˜²æ­¢ï¼‰
      if (!game.kifu.moves || game.kifu.moves.length === 0) return;

      if (!game.finishedAt) game.finishedAt = new Date().toISOString();
      if (!game.result) game.result = reason || "finished";

      // ç¢ºå®Ÿã«ä¿å­˜
      saveKifuToLocal();

      upsertGameIndex({
        gameId: game.gameId,
        room: currentRoom(),
        gameId: game.gameId || null,
        startedAt: game.startedAt || null,
        finishedAt: game.finishedAt || null,
        result: game.result || null,
        startedAt: game.startedAt || null,
        finishedAt: game.finishedAt,
        result: game.result,
        moves: game.kifu.moves.length,
        savedAt: new Date().toISOString()
      });
    }catch{}
  }

  function startNewGame(){
    // ç¾åœ¨ã®å¯¾å±€ã‚’ç¢ºå®šï¼ˆãƒªã‚»ãƒƒãƒˆå‰ï¼‰
    finalizeCurrentGame("reset");
    game = ensureKifu(normalizeRoles(initialGame()));
    game = ensureGameId(game);
    window.__KIWAMI_GAME = game;
    saveKifuToLocal(); // åˆæœŸçŠ¶æ…‹ã‚‚ä¿å­˜ã—ã¦ãŠãï¼ˆå¾©å…ƒç”¨ï¼‰
  }

  function kifuStorageKey(){
    ensureGameId(game);
    return `kiwami_kifu_v1:${currentRoom()}:${game.gameId}`;
  }

  function saveKifuToLocal(){
    try{
      ensureKifu(game);
      const payload = {
        format: "KiwamiShogiKifu",
        version: 1,
        room: currentRoom(),
        savedAt: new Date().toISOString(),
        initial: "standard",
        moves: game.kifu.moves || []
      };
      localStorage.setItem(kifuStorageKey(), JSON.stringify(payload));
    }catch{}
  }

  function loadKifuFromLocal(){
    try{
      const raw = localStorage.getItem(kifuStorageKey());
      if (!raw){
        // æ—§å½¢å¼ï¼ˆéƒ¨å±‹å˜ä½ï¼‰ã‹ã‚‰ã®äº’æ›èª­è¾¼
        const legacyKey = `kiwami_kifu_v1:${currentRoom()}`;
        const legacy = localStorage.getItem(legacyKey);
        if (!legacy) return { ok:false, msg:"ä¿å­˜æ¸ˆã¿æ£‹è­œãŒã‚ã‚Šã¾ã›ã‚“" };
        // æ—§ãƒ‡ãƒ¼ã‚¿ã‚’ç¾åœ¨ã®å¯¾å±€IDã¸å–ã‚Šè¾¼ã¿
        const legacyObj = JSON.parse(legacy);
        ensureGameId(game);
        const migrated = {
          moves: legacyObj.moves || [],
          cursor: (legacyObj.moves || []).length
        };
        ensureKifu(game);
        game.kifu.moves = migrated.moves;
        game.kifu.cursor = migrated.cursor;
        rebuildToCursor(game.kifu.cursor);
        // æ–°ã‚­ãƒ¼ã§ä¿å­˜ï¼ˆä»¥å¾Œã¯è©¦åˆå˜ä½ï¼‰
        saveKifuToLocal();
        return { ok:true, msg:`æ—§å½¢å¼æ£‹è­œã‚’ç§»è¡Œèª­è¾¼ï¼ˆæ‰‹æ•° ${migrated.moves.length}ï¼‰` };
      }
      const obj = JSON.parse(raw);
      if (!obj || !Array.isArray(obj.moves)) return { ok:false, msg:"ä¿å­˜æ£‹è­œãŒå£Šã‚Œã¦ã„ã¾ã™ï¼ˆmovesãŒã‚ã‚Šã¾ã›ã‚“ï¼‰" };
      ensureKifu(game);
      game.kifu.moves = obj.moves;
      game.kifu.cursor = obj.moves.length;
      rebuildToCursor(game.kifu.cursor);
      return { ok:true, msg:`ãƒ­ãƒ¼ã‚«ãƒ«æ£‹è­œã‚’èª­è¾¼ï¼ˆæ‰‹æ•° ${obj.moves.length}ï¼‰` };
    }catch{
      return { ok:false, msg:"ä¿å­˜æ£‹è­œã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ" };
    }
  }

  function deleteKifuLocal(){
    try{ localStorage.removeItem(kifuStorageKey()); }catch{}
  }

  function basePieceForHand(p){
    if (!p) return null;
    const up = p.toUpperCase();
    const map = { "+P":"P", "+L":"L", "+N":"N", "+S":"S", "+B":"B", "+R":"R" };
    if (map[up]) return (p === up) ? map[up] : map[up].toLowerCase();
    return p;
  }

  function applyKifuRecord(g, rec){
    normalizeHands(g);
    normalizeRoles(g);

    if (rec.type === "move"){
      // remove from
      g.board[rec.from.r][rec.from.c] = null;

      // capture -> hand
      if (rec.capture){
        const bp = basePieceForHand(rec.capture);
        const key = bp.toUpperCase();
        g.hands[rec.side][key] = (g.hands[rec.side][key] || 0) + 1;
      }

      // place pieceAfter
      g.board[rec.to.r][rec.to.c] = rec.pieceAfter;

      g.turn = (rec.side === "S") ? "G" : "S";
      return;
    }

    if (rec.type === "drop"){
      const key = rec.piece.toUpperCase();
      const cur = (g.hands[rec.side][key] || 0);
      if (cur > 0){
        if (cur === 1) delete g.hands[rec.side][key];
        else g.hands[rec.side][key] = cur - 1;
      }
      const p = (rec.side === "S") ? key : key.toLowerCase();
      g.board[rec.to.r][rec.to.c] = p;
      g.turn = (rec.side === "S") ? "G" : "S";
      return;
    }
  }

  function rebuildToCursor(cursor){
    ensureKifu(game);
    const moves = game.kifu.moves || [];
    const c = Math.max(0, Math.min(cursor, moves.length));

    const rebuilt = normalizeRoles(normalizeHands(initialGame()));
    rebuilt.roles = game.roles ? JSON.parse(JSON.stringify(game.roles)) : {S:null,G:null};
    rebuilt.hands = { S:{}, G:{} };
    rebuilt.turn = "S";
    ensureKifu(rebuilt);
    rebuilt.kifu.moves = JSON.parse(JSON.stringify(moves));
    rebuilt.kifu.cursor = c;

    for (let i=0; i<c; i++){
      applyKifuRecord(rebuilt, moves[i]);
    }

    game.board = rebuilt.board;
    game.turn  = rebuilt.turn;
    game.hands = rebuilt.hands;
    game.roles = rebuilt.roles;
    game.kifu  = rebuilt.kifu;

    
    // set lastMove for review highlight
    lastMove = null;
    if (c > 0){
      const rec = moves[c-1];
      if (rec){
        if (rec.type === "move") lastMove = { from: rec.from, to: rec.to };
        else if (rec.type === "drop") lastMove = { from: {r:-1,c:-1}, to: rec.to };
      }
    }
selected = null;
    selectedDrop = null;
    draw();
    updateKifuUI();
  }

  function recordMove(side, from, to, pieceAfter, capture){
    ensureKifu(game);
    if (game.kifu.cursor !== game.kifu.moves.length){
      game.kifu.moves = game.kifu.moves.slice(0, game.kifu.cursor);
    }
    game.kifu.moves.push({
      type:"move",
      side,
      from:{r:from.r, c:from.c},
      to:{r:to.r, c:to.c},
      pieceAfter,
      capture: capture || null
    });
    game.kifu.cursor = game.kifu.moves.length;
    updateKifuUI();
    if (kifuAutoEnabled) saveKifuToLocal();
  }

  function recordDrop(side, pieceKey, to){
    ensureKifu(game);
    if (game.kifu.cursor !== game.kifu.moves.length){
      game.kifu.moves = game.kifu.moves.slice(0, game.kifu.cursor);
    }
    game.kifu.moves.push({
      type:"drop",
      side,
      piece: pieceKey.toUpperCase(),
      to:{r:to.r, c:to.c}
    });
    game.kifu.cursor = game.kifu.moves.length;
    updateKifuUI();
    if (kifuAutoEnabled) saveKifuToLocal();
  }

  function exportKifuJSON(){
    ensureKifu(game);
    return JSON.stringify({
      format: "KiwamiShogiKifu",
      version: 1,
      room: currentRoom(),
      createdAt: new Date().toISOString(),
      initial: "standard",
      moves: game.kifu.moves || []
    }, null, 2);
  }

  function importKifuJSON(text){
    // tolerate pasted logs / timestamps / BOM etc.
    let t = (text || "").trim();

    // Strip UTF-8 BOM if present
    if (t.charCodeAt(0) === 0xFEFF) t = t.slice(1).trim();

    // If user pasted with prefix (e.g., "2026/01/17 16:57 ...{json}")
    const firstObj = t.search(/[\{\[]/);
    if (firstObj > 0) t = t.slice(firstObj).trim();

    let obj = null;
    try{
      obj = JSON.parse(t);
    }catch(e){
      const msg = (e && e.message) ? e.message : "parse error";
      return { ok:false, msg:`JSONã¨ã—ã¦è§£æã§ãã¾ã›ã‚“ï¼ˆ${msg}ï¼‰` };
    }

    // Accept formats:
    // 1) {moves:[...]}
    // 2) {kifu:{moves:[...]}}
    // 3) [...]  (array of records)
    let moves = null;
    if (Array.isArray(obj)) moves = obj;
    else if (obj && Array.isArray(obj.moves)) moves = obj.moves;
    else if (obj && obj.kifu && Array.isArray(obj.kifu.moves)) moves = obj.kifu.moves;

    if (!moves) return { ok:false, msg:"movesé…åˆ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“" };

    ensureKifu(game);
    game.kifu.moves = moves;
    game.kifu.cursor = moves.length;
    rebuildToCursor(game.kifu.cursor);
    return { ok:true, msg:`ã‚¤ãƒ³ãƒãƒ¼ãƒˆOKï¼ˆæ‰‹æ•° ${moves.length}ï¼‰` };
  }


  let myName = "guest";
  let mySide = null; // "S" or "G" is learned from your first move/drop


  function setStatus(t){ statusEl.textContent = t; }

  function updateKifuUI(){
    ensureKifu(game);
    const total = game.kifu.moves.length;
    const cur = game.kifu.cursor;
    if (kifuStep) kifuStep.textContent = `æ‰‹æ•° ${cur} / ${total}`;
    if (btnKifuPrev) btnKifuPrev.disabled = (cur <= 0);
    if (btnKifuNext) btnKifuNext.disabled = (cur >= total);
  }

  function setTurnUI(){
    const base = (game.turn === "S") ? "å…ˆæ‰‹" : "å¾Œæ‰‹";
    const you = (mySide && game.turn === mySide) ? "ï¼ˆã‚ãªãŸï¼‰" : "";
    const t = base + you;
    turnText.textContent = `æ‰‹ç•ª: ${t}`;
    handHintS.textContent = (game.turn === "S") ? "ï¼ˆæ‰‹ç•ªãªã‚‰é¸æŠã§ãã¾ã™ï¼‰" : "";
    handHintG.textContent = (game.turn === "G") ? "ï¼ˆæ‰‹ç•ªãªã‚‰é¸æŠã§ãã¾ã™ï¼‰" : "";
    const badge = document.getElementById("turnBadge");
    if (badge){
      badge.classList.remove("turnMine","turnOther");
      if (mySide){
        badge.classList.add((game.turn === mySide) ? "turnMine" : "turnOther");
      }
    }
  }

  function sideLabel(side){ return side === "S" ? "å…ˆæ‰‹" : "å¾Œæ‰‹"; }

  function isKingPiece(p){
    const b = basePiece(p);
    return b === "K" || b === "k";
  }

  function showWinPopup(winnerSide){
    // ç‹ãŒå–ã‚‰ã‚ŒãŸå¾Œã¯ã€Œå‹ã¡ã€ã ã‘è¡¨ç¤ºï¼ˆãƒ–ãƒ©ã‚¦ã‚¶alertã¯ä½¿ã‚ãªã„ï¼‰
    uiAlert(`${sideLabel(winnerSide)}ã®å‹ã¡`);
  }


  // ---- éŸ³ï¼ˆWebAudioï¼‰ ----
  function buzz(ms=10){
    if(!vibrationEnabled) return;
    try{ if (navigator.vibrate) navigator.vibrate(ms); }catch{}
  }
  audioEnabled = (typeof audioEnabled === "boolean") ? audioEnabled : true;
  vibrationEnabled = (typeof vibrationEnabled === "boolean") ? vibrationEnabled : true;
  let audioCtx = null;
  function ensureAudioUnlocked(){
    if (!audioEnabled) return;
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
  }

  window.ensureAudioUnlocked = ensureAudioUnlocked;

  // ---- Audio unlock on first user gesture (mobile autoplay restriction) ----
  (function(){
    const once = () => { try{ ensureAudioUnlocked(); }catch{}; window.removeEventListener("pointerdown", once, true); window.removeEventListener("touchstart", once, true); };
    window.addEventListener("pointerdown", once, true);
    window.addEventListener("touchstart", once, true);
  })();
  function beep(freq=440, dur=0.06, type="sine", gain=0.06){
    if (!audioEnabled) return;
    ensureAudioUnlocked();
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t0); o.stop(t0+dur+0.02);
  }
  const sfx = {
    move(side){ 
      // å…ˆæ‰‹/å¾Œæ‰‹ã§éŸ³ç¨‹ã‚’å¤‰ãˆã‚‹
      const f = (side === "G") ? 460 : 520;
      beep(f, 0.05, "square", 0.05); 
      buzz(8);
    },
    capture(side){ 
      const f1 = (side === "G") ? 210 : 220;
      const f2 = (side === "G") ? 170 : 180;
      beep(f1, 0.07, "triangle", 0.06); 
      beep(f2, 0.05, "triangle", 0.05); 
      buzz(15);
    },
    promote(side){ 
      const f1 = (side === "G") ? 700 : 740;
      const f2 = (side === "G") ? 930 : 980;
      beep(f1, 0.05, "sine", 0.05); 
      beep(f2, 0.06, "sine", 0.05); 
      buzz(10);
    },
    drop(side){ 
      const f = (side === "G") ? 390 : 430;
      beep(f, 0.06, "square", 0.05); 
      buzz(10);
    },
    chat(){ 
      beep(660, 0.04, "sine", 0.04); 
      buzz(6);
    }
  };

  btnSound.addEventListener("click", () => {
    audioEnabled = !audioEnabled;
    btnSound.textContent = audioEnabled ? "ğŸ”Š éŸ³: ON" : "ğŸ”‡ éŸ³: OFF";
    if (audioEnabled) ensureAudioUnlocked();
  });

  function appendChat(user, text){
    const div = document.createElement("div");
    div.className = "msg";
    div.innerHTML = `<b>${esc(user)}</b> <span class="small" style="opacity:.7;margin-left:.35rem">${fmtDT()}</span><div style="margin-top:2px">${esc(text)}</div>`;
    chatLog.appendChild(div);
    chatLog.scrollTop = chatLog.scrollHeight;
  }
  function appendSystem(text){
    const div = document.createElement("div");
    div.className = "msg";
    div.innerHTML = `<span class="small" style="opacity:.7;margin-right:.35rem">${fmtDT()}</span><span class="small">${esc(text)}</span>`;
    chatLog.appendChild(div);
    chatLog.scrollTop = chatLog.scrollHeight;
  }
  function fmtDT(d=new Date()){
    // yyyy/mm/dd hh:mm
    const pad = (n)=>String(n).padStart(2,"0");
    return `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }

  function esc(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#39;");
  }
const escapeHtml = esc;
  window.escapeHtml = esc;
  window.fmtDT = fmtDT;


  function drawHands(){
    const s = game.hands.S || {};
    const g = game.hands.G || {};
    handS.innerHTML = "";
    handG.innerHTML = "";

    const render = (side, el) => {
      const h = side === "S" ? s : g;
      let any = false;

      for (const t of HAND_ORDER){
        const n = Number(h[t] || 0);
        if (n <= 0) continue;
        any = true;

        const chip = document.createElement("button");
        chip.className = "chip";
        chip.type = "button";
        chip.innerHTML = `<span>${HAND_LABEL[t]}</span><span class="cnt">Ã—${n}</span>`;

        const isMyTurn = (game.turn === side);
        if (!isMyTurn){
          chip.classList.add("disabled");
          chip.disabled = true;
        } else {
          chip.addEventListener("click", () => {
            ensureAudioUnlocked();
            selected = null;
            if (selectedDrop && selectedDrop.side === side && selectedDrop.type === t) selectedDrop = null;
            else selectedDrop = { side, type: t };
            draw();
          });
        }

        if (selectedDrop && selectedDrop.side === side && selectedDrop.type === t) chip.classList.add("sel");
        el.appendChild(chip);
      }

      if (!any){
        const span = document.createElement("span");
        span.className = "small";
        span.textContent = "ï¼ˆãªã—ï¼‰";
        el.appendChild(span);
      }
    };

    render("S", handS);
    render("G", handG);
  }

  function draw(){
    normalizeHands(game);
    normalizeRoles(game);
    setTurnUI();
    drawHands();

    boardEl.innerHTML = "";
    for (let vr=0; vr<9; vr++){
      for (let vc=0; vc<9; vc++){
        const povFlip = (mySide === "G");
        const r = povFlip ? (8 - vr) : vr;
        const c = povFlip ? (8 - vc) : vc;
        const p = game.board[r][c];
        const d = document.createElement("div");
        d.className =
          "cell" +
          (p && ((mySide === "G") ? isSente(p) : isGote(p)) ? " rev" : "") +
          (selected && selected.r===r && selected.c===c ? " sel" : "") +
          (lastMove && lastMove.from && lastMove.from.r===r && lastMove.from.c===c ? " lastFrom" : "") +
          (lastMove && lastMove.to   && lastMove.to.r===r   && lastMove.to.c===c   ? " lastTo"   : "")
          ;

        d.dataset.r = r;
        d.dataset.c = c;

        const pieceSpan = document.createElement("span");
        pieceSpan.className = "piece" + (p && isPromoted(p) ? " promoted" : "");
        pieceSpan.textContent = p ? (PIECE[p] || PIECE[basePiece(p)] || "") : "";
        d.appendChild(pieceSpan);

        const coord = document.createElement("span");
        coord.className = "coord";
        coord.textContent = `${9 - c}${r + 1}`;
        d.appendChild(coord);

        boardEl.appendChild(d);
      }
    }
  }

  // ---- æˆã‚Š ----
  function inPromoZone(turn, r){
    if (turn === "S") return r <= 2;
    return r >= 6;
  }
  function canPromote(pieceBase){
    return !["K","G","k","g"].includes(pieceBase);
  }

  async function decidePromotionAsync(turn, piece, fromR, toR){
    if (!piece) return false;
    const base = basePiece(piece);
    if (!canPromote(base)) return false;
    if (!isPromotableMove(turn, piece, fromR, toR)) return false;
    if (isForcedPromotion(turn, piece, toR)) return true;
    // use in-page modal (no browser confirm)
    return await uiConfirm("æˆã‚Šã¾ã™ã‹ï¼Ÿ", "æˆã‚‹", "æˆã‚‰ãªã„");
  }

  function isPromotableMove(turn, piece, fromR, toR){
    if (!piece) return false;
    if (isPromoted(piece)) return false;
    const b = basePiece(piece);
    if (!canPromote(b)) return false;
    return inPromoZone(turn, fromR) || inPromoZone(turn, toR);
  }
  function isForcedPromotion(turn, piece, toR){
    const b = basePiece(piece).toUpperCase();
    if (b === "P" || b === "L"){
      return (turn === "S") ? (toR === 0) : (toR === 8);
    }
    if (b === "N"){
      return (turn === "S") ? (toR <= 1) : (toR >= 7);
    }
    return false;
  }
  function decidePromotion(turn, piece, fromR, toR){
    if (!isPromotableMove(turn, piece, fromR, toR)) return false;
    if (isForcedPromotion(turn, piece, toR)) return true;
    return window.confirm("æˆã‚Šã¾ã™ã‹ï¼Ÿ");
  }
  function applyPromotion(piece){
    if (!piece || isPromoted(piece)) return piece;
    return "+" + piece;
  }

  // ---- æŒã¡é§’ ----
  function addToHand(side, capturedPiece){
    const b = basePiece(capturedPiece);
    const t = b.toUpperCase();
    game.hands[side][t] = Number(game.hands[side][t] || 0) + 1;
  }

  function canDropHere(side, type, r, c){
    if (game.board[r][c] != null) return false;

    // è¡Œãæ‰€ã®ãªã„é§’ï¼ˆæœ€ä½é™ï¼‰
    if (type === "P" || type === "L"){
      if (side === "S" && r === 0) return false;
      if (side === "G" && r === 8) return false;
    }
    if (type === "N"){
      if (side === "S" && r <= 1) return false;
      if (side === "G" && r >= 7) return false;
    }

    // äºŒæ­©ï¼ˆæœ€ä½é™ï¼‰
    if (type === "P"){
      for (let rr=0; rr<9; rr++){
        const p = game.board[rr][c];
        if (!p) continue;
        if (side === "S" && p === "P") return false;
        if (side === "G" && p === "p") return false;
      }
    }
    return true;
  }

  function dropPiece(side, type, r, c){
    if (!canDropHere(side, type, r, c)){
      appendSystem("ãã®å ´æ‰€ã«ã¯æ‰“ã¦ã¾ã›ã‚“ï¼ˆç©ºã/äºŒæ­©/è¡Œãæ‰€ãªã—ï¼‰");
      return false;
    }
    const h = game.hands[side];
    if (Number(h[type] || 0) <= 0) return false;

    const piece = (side === "S") ? type : type.toLowerCase();
    game.board[r][c] = piece;
    h[type] = Number(h[type]) - 1;
    if (h[type] <= 0) delete h[type];
    return true;
  }

  
  function roleLabel(){ return mySide ? (mySide === "S" ? "ï¼ˆå…ˆæ‰‹ï¼‰" : "ï¼ˆå¾Œæ‰‹ï¼‰") : "ï¼ˆè¦³æˆ¦ï¼‰"; }

  function updateMySideFromRoles(){
    normalizeRoles(game);
    const rs = game.roles.S;
    const rg = game.roles.G;
    if (rs && rs.id === clientId) mySide = "S";
    else if (rg && rg.id === clientId) mySide = "G";
    else mySide = null;
  }

  async function claimRoleIfNeeded(){
    normalizeRoles(game);
    updateMySideFromRoles();

    // If already assigned, nothing to do
    if (mySide) { appendSystem(`ã‚ãªãŸã¯${mySide==="S"?"å…ˆæ‰‹":"å¾Œæ‰‹"}ã§ã™`); return; }

    const sTaken = !!game.roles.S;
    const gTaken = !!game.roles.G;

    // Both taken -> spectator
    if (sTaken && gTaken){
      appendSystem("ã“ã®éƒ¨å±‹ã¯å¯¾å±€è€…ãŒæƒã£ã¦ã„ã¾ã™ï¼ˆè¦³æˆ¦ãƒ¢ãƒ¼ãƒ‰ï¼‰");
      return;
    }

    // First entrant (none taken): choose
    if (!sTaken && !gTaken){
      const ok = await uiConfirm("å…ˆæ‰‹ã§å…¥ã‚Šã¾ã™ã‹ï¼Ÿ", "å…ˆæ‰‹", "å¾Œæ‰‹");
      const side = ok ? "S" : "G";
      game.roles[side] = { id: clientId, name: myName };
      updateMySideFromRoles();
      appendSystem(`å½¹å‰²ã‚’ç¢ºå®šï¼š${side==="S"?"å…ˆæ‰‹":"å¾Œæ‰‹"}`);
      sendState();
      draw();
      return;
    }

    // One remaining: auto assign
    const side = sTaken ? "G" : "S";
    game.roles[side] = { id: clientId, name: myName };
    updateMySideFromRoles();
    appendSystem(`å½¹å‰²ã‚’ç¢ºå®šï¼š${side==="S"?"å…ˆæ‰‹":"å¾Œæ‰‹"}`);
    sendState();
    draw();
  }


  // ---- WS ----
  function currentRoom(){
    return (location.hash.match(/room=([a-zA-Z0-9_-]+)/)?.[1]) || "lobby";
  }

  function connect(){
    ensureAudioUnlocked();
    const room = currentRoom();
    myName = (nameEl.value || "guest").trim().slice(0, 24) || "guest";
    try{ localStorage.setItem("shogi_name", myName); }catch{}


    if (ws) { try{ ws.close(); }catch{} ws=null; }
    ws = new WebSocket(`${WORKER_WS}/?room=${encodeURIComponent(room)}`);
    gotState = false;

    ws.onopen = () => {
      setStatus(`æ¥ç¶šä¸­â€¦ room=${room}`);
      appendSystem(`æ¥ç¶šã—ã¾ã—ãŸï¼ˆroom=${room}ï¼‰`);
      ws.send(JSON.stringify({ type:"join", user:myName, room, payload:"" }));
      // State restore is expected from server (é€”ä¸­å‚åŠ ã§å¾©å…ƒ).
      // If not received shortly, publish our initial state (first entrant).
      setTimeout(() => {
        if (!gotState){
          sendState();
        }
      }, 250);

    };

    ws.onclose = () => { setStatus("åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ"); appendSystem("åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ"); };
    ws.onerror = () => { setStatus("æ¥ç¶šã‚¨ãƒ©ãƒ¼ï¼ˆURL/WorkerçŠ¶æ…‹ã‚’ç¢ºèªï¼‰"); appendSystem("æ¥ç¶šã‚¨ãƒ©ãƒ¼"); };

    ws.onmessage = (ev) => {
      let m; try{ m = JSON.parse(ev.data); }catch{ return; }

      if (m.type === "state" && m.payload && m.payload.board){
        gotState = true;

        // â˜…é‡è¦ï¼šã‚µãƒ¼ãƒã®stateã¯ç›¤é¢åŒæœŸç”¨ï¼ˆæ£‹è­œã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç®¡ç†ï¼‰
        // è‡ªåˆ†ã®é€ä¿¡ã—ãŸstateã‚‚æˆ»ã£ã¦ãã‚‹ãŸã‚ã€ãã®ãŸã³ã« game ã‚’ä½œã‚Šç›´ã™ã¨æ£‹è­œãŒæ¶ˆãˆã‚‹ã€‚
        // â†’ å—ä¿¡å‰ã®æ£‹è­œã‚’é€€é¿ã—ã€å—ä¿¡å¾Œã«å¾©å…ƒã™ã‚‹ï¼ˆpayloadã«æ£‹è­œãŒç„¡ã„å‰æï¼‰
        const prevKifu = (window.__KIWAMI_GAME && window.__KIWAMI_GAME.kifu)
          ? JSON.parse(JSON.stringify(window.__KIWAMI_GAME.kifu))
          : null;
        const prevGameId = (window.__KIWAMI_GAME && window.__KIWAMI_GAME.gameId) ? window.__KIWAMI_GAME.gameId : null;
        const prevStartedAt = (window.__KIWAMI_GAME && window.__KIWAMI_GAME.startedAt) ? window.__KIWAMI_GAME.startedAt : null;
        const prevFinishedAt = (window.__KIWAMI_GAME && window.__KIWAMI_GAME.finishedAt) ? window.__KIWAMI_GAME.finishedAt : null;
        const prevResult = (window.__KIWAMI_GAME && window.__KIWAMI_GAME.result) ? window.__KIWAMI_GAME.result : null;

        game = ensureKifu(normalizeRoles(normalizeHands(m.payload)));

        // å¯¾å±€IDã‚‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ä¿æŒï¼ˆå—ä¿¡stateã«ç„¡ã„å ´åˆãŒã‚ã‚‹ï¼‰
        if (prevGameId && !game.gameId) game.gameId = prevGameId;
        if (prevStartedAt && !game.startedAt) game.startedAt = prevStartedAt;
        if (prevFinishedAt && !game.finishedAt) game.finishedAt = prevFinishedAt;
        if (prevResult && !game.result) game.result = prevResult;

        // å—ä¿¡stateã«æ£‹è­œãŒç„¡ã„/ç©ºãªã‚‰ã€é€€é¿ã—ãŸæ£‹è­œã‚’å¾©å…ƒ
        try{
          if (prevKifu && (!game.kifu || !Array.isArray(game.kifu.moves) || game.kifu.moves.length === 0)){
            game.kifu = prevKifu;
          }
        }catch{}

        window.__KIWAMI_GAME = game;
        // ãƒ­ãƒ¼ã‚«ãƒ«æ£‹è­œãŒã‚ã‚Šã€ã‚µãƒ¼ãƒå´ãŒç©ºãªã‚‰è‡ªå‹•èª­è¾¼ï¼ˆMVPï¼‰
        try{
          if (didAutoLoadKifu){
            // already attempted once
          } else if (suppressAutoLoadOnce){
            suppressAutoLoadOnce = false;
            didAutoLoadKifu = true;
          } else {
            ensureKifu(game);
            if ((game.kifu.moves||[]).length === 0){
              const r = loadKifuFromLocal();
              if (r.ok) appendSystem(r.msg);
            }
            didAutoLoadKifu = true;
          }
        }catch{} 
        updateMySideFromRoles();
        selected = null;
        selectedDrop = null;
        updateKifuUI();
        draw();
        // Role is decided on first join (choose/auto) and persisted in state
        claimRoleIfNeeded();
        return;
      }

      if ((m.type === "chat" || m.type === "msg") && (m.payload || m.text)){
        const text = (typeof m.payload === "string") ? m.payload : (m.text ?? "");
        const user = m.user || "anon";
        appendChat(user, text);
        sfx.chat();
        return;
      }
      if (m.type === "join"){ appendSystem(`${m.user || "anon"} ãŒå…¥å®¤`); return; }
      if (m.type === "system"){ appendSystem(String(m.payload ?? "")); return; }
    };
  }

  function sendChat(){
    ensureAudioUnlocked();
    if (!ws || ws.readyState !== 1) return;
    const text = (chatInput.value || "").trim();
    if (!text) return;
    const room = currentRoom();
    ws.send(JSON.stringify({ type:"msg", user:myName, room, payload:text }));
    chatInput.value = "";
    sfx.chat();
  }

  function sendState(){
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify({ type:"state", room: currentRoom(), payload: game }));
  }

  boardEl.addEventListener("click", async (e) => {
    ensureAudioUnlocked();
    const cell = e.target.closest(".cell");
    if (!cell) return;
    if (!ws || ws.readyState !== 1) return;

    const r = Number(cell.dataset.r);
    const c = Number(cell.dataset.c);

    // æ‰“ã¡å„ªå…ˆ
    if (selectedDrop){
      const side = selectedDrop.side;
      const type = selectedDrop.type;

      if (game.turn !== side){ appendSystem("æ‰‹ç•ªã§ã¯ã‚ã‚Šã¾ã›ã‚“"); return; }

      if (!dropPiece(side, type, r, c)) return;

      // æ£‹è­œã«è¨˜éŒ²ï¼ˆè‡ªå‹•å–å¾—ONãªã‚‰ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ã‚‚èµ°ã‚‹ï¼‰
      recordDrop(side, type, { r, c });

      lastMove = { from: { r: -1, c: -1 }, to: { r, c } };
      selectedDrop = null;
      selected = null;
      moverSide = game.turn;
      game.turn = (game.turn === "S") ? "G" : "S";
      draw();
      sendState();
      sfx.drop(moverSide);
      return;
    }

    // é€šå¸¸ã®é¸æŠ/ç§»å‹•
    if (!selected){
      const p = game.board[r][c];
      if (!p) return;

      const isS = (game.turn === "S");
      if (isS && !isSente(p)) return;
      if (!isS && !isGote(p)) return;

      selected = {r,c};
      draw();
      return;
    }

    const from = selected;
    let piece = game.board[from.r][from.c];
    if (!piece){ selected=null; draw(); return; }
    const dest = game.board[r][c];
    if (dest && toSide(dest) === game.turn){ selected=null; draw(); return; }

    // å…ˆã«æˆã‚Šåˆ¤å®šï¼ˆç›¤é¢ã‚’å‹•ã‹ã™å‰ã«ç¢ºèªã™ã‚‹ï¼šé§’ãŒæ¶ˆãˆãªã„ã‚ˆã†ã«ï¼‰
    const promote = await decidePromotionAsync(game.turn, piece, from.r, r);
    if (promote) piece = applyPromotion(piece);

    let didCapture = false;
    if (dest){
      didCapture = true;
      if (isKingPiece(dest)){
        // Capture king -> game over (show only)
        showWinPopup(game.turn);
        // å¯¾å±€çµ‚äº†ã¨ã—ã¦æ£‹è­œã‚’ç¢ºå®šä¿å­˜
        finalizeCurrentGame("win");
        // Do not add king to hand
      } else {
        addToHand(game.turn, dest);
      }
    }

    game.board[from.r][from.c] = null;
    game.board[r][c] = piece;
// æ£‹è­œã«è¨˜éŒ²ï¼ˆè‡ªå‹•å–å¾—ONãªã‚‰ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ã‚‚èµ°ã‚‹ï¼‰
    const captureForKifu = (dest && !isKingPiece(dest)) ? dest : null;
    recordMove(game.turn, from, { r, c }, piece, captureForKifu);

    lastMove = { from: { r: from.r, c: from.c }, to: { r, c } };
    selected = null;
    moverSide = game.turn;
    game.turn = (game.turn === "S") ? "G" : "S";
    draw();
    sendState();

    if (didCapture) sfx.capture(moverSide); else sfx.move(moverSide);
    if (promote) sfx.promote(moverSide);
  });

  // UI
  btnConnect.addEventListener("click", connect);
  btnCopyUrl.addEventListener("click", async () => {
    const room = currentRoom();
    const url = `${location.origin}${location.pathname}#room=${room}`;
    try{ await navigator.clipboard.writeText(url); appendSystem("éƒ¨å±‹ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ"); }
    catch{ appendSystem("ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶æ¨©é™ï¼‰"); }
  });
  btnFull.addEventListener("click", async () => {
    try{
      ensureAudioUnlocked();
      const el = document.documentElement;
      if (!document.fullscreenElement){
        if (el.requestFullscreen) await el.requestFullscreen();
      } else {
        if (document.exitFullscreen) await document.exitFullscreen();
      }
    }catch{}
  });

  btnChatToggle.addEventListener("click", () => {
    document.body.classList.toggle("chatOpen");
  });

  btnKifuDelete.addEventListener("click", async () => {
    if (!(await uiConfirm("ãƒ­ãƒ¼ã‚«ãƒ«ã®æ£‹è­œãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ", "å‰Šé™¤", "ã‚„ã‚ã‚‹"))) return;
    deleteKifuLocal();
    ensureKifu(game);
    game.kifu.moves = [];
    game.kifu.cursor = 0;
    rebuildToCursor(0);
    if (ws && ws.readyState === 1){
      ws.send(JSON.stringify({ type:"state", room: currentRoom(), payload: game }));
    }
    appendSystem("æ£‹è­œãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ");
  });

  btnKifuImport.addEventListener("click", () => {
    const res = importKifuJSON(kifuText.value || "");
    appendSystem(res.msg);
    if (res.ok){
      // ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ãŸæ£‹è­œã¯ãƒ­ãƒ¼ã‚«ãƒ«ã«ã‚‚ä¿å­˜ï¼ˆä»¥å¾Œã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã«åˆ©ç”¨ï¼‰
      saveKifuToLocal();
    }
    if (ws && ws.readyState === 1){
      ws.send(JSON.stringify({ type:"state", room: currentRoom(), payload: game }));
    }
  });
  btnKifuPrev.addEventListener("click", () => {
    ensureKifu(game);
    rebuildToCursor(game.kifu.cursor - 1);
  });
  btnKifuNext.addEventListener("click", () => {
    ensureKifu(game);
    rebuildToCursor(game.kifu.cursor + 1);
  });

btnReset.addEventListener("click", () => {
  ensureAudioUnlocked();
  // --- reset UI state ---
  lastMove = null;        // â˜… å¼·èª¿è¡¨ç¤ºã‚’æ¶ˆã™
  selected = null;        // â˜… é¸æŠä¸­ã®é§’ã‚’è§£é™¤
  selectedDrop = null;    // â˜… æŒã¡é§’é¸æŠã‚’è§£é™¤

  suppressAutoLoadOnce = true;
  didAutoLoadKifu = true;

  startNewGame();
  draw();
  sendState();
});


  btnSend.addEventListener("click", sendChat);
  chatInput.addEventListener("keydown", (e) => { if (e.key === "Enter") sendChat(); });

  draw();
})();

  // ---- Mobile Menu (Settings / Kifu) ----
  const mobileDrawer = document.getElementById("mobileDrawer");
  const mobileMenuBtn = document.getElementById("mobileMenuBtn");
  const tabSettings = document.getElementById("tabSettings");
  const tabKifu = document.getElementById("tabKifu");
  const btnDrawerClose = document.getElementById("btnDrawerClose");
  const drawerSettings = document.getElementById("drawerSettings");
  const drawerKifu = document.getElementById("drawerKifu");
  const drawerKifuHost = document.getElementById("drawerKifuHost");
  const kifuDock = document.getElementById("kifuDock");
  const kifuPanel = document.getElementById("kifuPanel");

  function drawerOpen(section){
    mobileDrawer.style.display = "block";
    mobileDrawer.setAttribute("aria-hidden","false");
    drawerSwitch(section);
  }
  function drawerClose(){
    mobileDrawer.style.display = "none";
    mobileDrawer.setAttribute("aria-hidden","true");
  }
  function drawerSwitch(section){
    drawerSettings.classList.toggle("active", section==="settings");
    drawerKifu.classList.toggle("active", section==="kifu");

    const isMobile = window.matchMedia("(max-width: 1100px)").matches ||
                     window.matchMedia("(hover: none) and (pointer: coarse)").matches;
    if (isMobile){
      if (kifuPanel && drawerKifuHost && kifuPanel.parentElement !== drawerKifuHost){
        drawerKifuHost.appendChild(kifuPanel);
      }
    } else {
      if (kifuPanel && kifuDock){
        // restore right after placeholder (desktop layout)
        kifuDock.insertAdjacentElement("afterend", kifuPanel);
      }
      drawerClose();
    }
  }

  if (mobileMenuBtn) mobileMenuBtn.addEventListener("click", ()=>drawerOpen("settings"));
  if (btnDrawerClose) btnDrawerClose.addEventListener("click", drawerClose);
  if (mobileDrawer) mobileDrawer.addEventListener("click", (e)=>{ if(e.target===mobileDrawer) drawerClose(); });
  if (tabSettings) tabSettings.addEventListener("click", ()=>drawerSwitch("settings"));
  if (tabKifu) tabKifu.addEventListener("click", ()=>drawerSwitch("kifu"));
  window.addEventListener("resize", ()=>drawerSwitch(drawerSettings.classList.contains("active")?"settings":"kifu"));

  // ---- Settings (sound/vibration) ----
  const LS_SETTINGS_KEY = "kiwami_settings_v1";
  function loadSettings(){
    try{ return JSON.parse(localStorage.getItem(LS_SETTINGS_KEY) || "{}"); }catch{ return {}; }
  }
  function saveSettings(){
    try{ localStorage.setItem(LS_SETTINGS_KEY, JSON.stringify({audioEnabled, vibrationEnabled})); }catch{}
  }

  const chkAudio = document.getElementById("chkAudio");
  const chkVibe  = document.getElementById("chkVibe");
  const s0 = loadSettings();
  if (typeof s0.audioEnabled === "boolean") audioEnabled = s0.audioEnabled;
  if (typeof s0.vibrationEnabled === "boolean") vibrationEnabled = s0.vibrationEnabled;
  if (chkAudio) chkAudio.checked = !!audioEnabled;
  if (chkVibe)  chkVibe.checked  = !!vibrationEnabled;

  if (chkAudio) chkAudio.addEventListener("change", ()=>{
    audioEnabled = chkAudio.checked;
    if (audioEnabled) ensureAudioUnlocked();
    saveSettings();
  });
  if (chkVibe) chkVibe.addEventListener("change", ()=>{
    vibrationEnabled = chkVibe.checked;
    saveSettings();
  });


// --- AI Review Logic ---
const btnAiReview = document.getElementById("btnAiReview");
const aiResultModal = document.getElementById("aiResultModal");
const aiResultBody = document.getElementById("aiResultBody");
const esc = window.escapeHtml || function(s){
  const map = { "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#39;" };
  return String(s).replace(/[&<>"']/g, (c)=>map[c]||c);
};


// Close AI modal when clicking backdrop
(function(){
  const m = document.getElementById("aiResultModal");
  if (m){
    m.addEventListener("click", (e)=>{ if(e.target===m) m.style.display="none"; });
  }
})();

if (btnAiReview) {
  btnAiReview.addEventListener("click", async () => {
    // æ£‹è­œãŒç©ºãªã‚‰æ­¢ã‚ã‚‹
    const g = window.__KIWAMI_GAME;

    // ãƒ¢ãƒ¼ãƒ€ãƒ«è¦ç´ ã¯DOMæ§‹ç¯‰å¾Œã«å­˜åœ¨ã™ã‚‹å‰æã ãŒã€ç’°å¢ƒã«ã‚ˆã£ã¦ null ã«ãªã‚‹ã“ã¨ãŒã‚ã‚‹ãŸã‚æ¯å›å–å¾—
    const modal = document.getElementById("aiResultModal");
    const body = document.getElementById("aiResultBody");
    if (!modal || !body) {
      // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒç„¡ã„å ´åˆã¯æœ€ä½é™ã®é€šçŸ¥ã§ç¶™ç¶š
      if (window.uiAlert) await window.uiAlert("AIçµæœè¡¨ç¤ºã‚¨ãƒªã‚¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆaiResultModal/aiResultBodyï¼‰");
      else alert("AIçµæœè¡¨ç¤ºã‚¨ãƒªã‚¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆaiResultModal/aiResultBodyï¼‰");
      return;
    }
    if (!g || !g.kifu || !Array.isArray(g.kifu.moves) || g.kifu.moves.length === 0) {
      if (window.uiAlert) await window.uiAlert("æ£‹è­œãŒã‚ã‚Šã¾ã›ã‚“ã€‚å°‘ã—æŒ‡ã—ã¦ã‹ã‚‰å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚");
      else alert("æ£‹è­œãŒã‚ã‚Šã¾ã›ã‚“ã€‚å°‘ã—æŒ‡ã—ã¦ã‹ã‚‰å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚");
      return;
    }

    // UIè¡¨ç¤º
    modal.style.display = "block";
    body.innerHTML = `<div class="ai-loading">ğŸ¤– AIãŒæ€è€ƒä¸­...<br><span class="small">â€»30ç§’ã»ã©ã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™</span></div>`;

    try {
      // 1. æ£‹è­œãƒ‡ãƒ¼ã‚¿ã®æ•´å½¢ï¼ˆAIãŒèª­ã¿ã‚„ã™ã„ã‚ˆã†ã«è»½é‡åŒ–ï¼‰
      const kifuExport = {
        moves: g.kifu.moves.map(m => {
          if (m.type === "move") return { s:m.side, f:m.from, t:m.to, p:m.pieceAfter };
          if (m.type === "drop") return { s:m.side, d:m.piece, t:m.to };
          return m;
        })
      };

      // 2. Geminiå‘¼ã³å‡ºã—ï¼ˆæ—¢å­˜ã®é–¢æ•°ã‚’åˆ©ç”¨ï¼‰
      const result = await reviewGameWithGemini(kifuExport);

      // 3. çµæœã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
      renderAiResult(result);

    } catch (e) {
      console.error(e);
      body.innerHTML = `<div style="color:#ff8888">ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚<br>${e.message}</div>`;
    }
  });
}

// AIçµæœã‚’HTMLã«å¤‰æ›ã—ã¦è¡¨ç¤º
function renderAiResult(data) {
  let html = "";

  // ç·è©•
  if (data.summary) {
    html += `<div class="ai-section"><h2>ç·è©•</h2><p>${esc(data.summary)}</p></div>`;
  }

  // å‹è² ã®åˆ†ã‹ã‚Œç›®
  if (data.turningPoints && data.turningPoints.length > 0) {
    html += `<div class="ai-section"><h3>âš¡ å‹è² ã®åˆ†ã‹ã‚Œç›®</h3>`;
    data.turningPoints.forEach(tp => {
      html += `<div style="margin-bottom:10px;">
        <b>${tp.ply}æ‰‹ç›®</b>: ${esc(tp.comment)}<br>
        <span class="small muted">æ¨å¥¨æ‰‹: ${tp.betterIdeas ? esc(tp.betterIdeas.join(", ")) : "ç‰¹ã«ãªã—"}</span>
      </div>`;
    });
    html += `</div>`;
  }

  // è‰¯ã‹ã£ãŸæ‰‹
  if (data.goodMoves && data.goodMoves.length > 0) {
    html += `<div class="ai-section"><h3>ğŸ‘ ãƒŠã‚¤ã‚¹ä¸€æ‰‹</h3>`;
    data.goodMoves.forEach(gm => {
      html += `<div><b>${gm.ply}æ‰‹ç›®</b>: <span class="ai-good">${esc(gm.comment)}</span></div>`;
    });
    html += `</div>`;
  }

  // æ‚ªæ‰‹ãƒ»æ”¹å–„ç‚¹
  if (data.badMoves && data.badMoves.length > 0) {
    html += `<div class="ai-section"><h3>ğŸ¤” æ”¹å–„ãƒã‚¤ãƒ³ãƒˆ</h3>`;
    data.badMoves.forEach(bm => {
      html += `<div style="margin-bottom:8px;">
        <b>${bm.ply}æ‰‹ç›®</b>: ${esc(bm.comment)}<br>
        <span class="ai-bad">æ”¹å–„æ¡ˆ: ${esc(bm.fix)}</span>
      </div>`;
    });
    html += `</div>`;
  }

  const body = document.getElementById("aiResultBody") || aiResultBody;
  if (body) body.innerHTML = html;
}

async function callGemini(prompt, model="gemini-2.5-flash") {
  const base = (window.AI_HTTP || location.origin).replace(/\/$/, "");
  const endpoint = `${base}/ai/gemini`;
  const res = await fetch(endpoint , {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt, model }),
  });
  const json = await res.json();
  if (!json.ok) throw new Error(json?.data ? JSON.stringify(json.data) : "Gemini error");
  return json.text;
}

async function reviewGameWithGemini(kifuJson) {
  const prompt = `
ã‚ãªãŸã¯å°†æ£‹ã®æ¤œè¨å½¹ã§ã™ã€‚æ¬¡ã®æ£‹è­œã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã¦ãã ã•ã„ã€‚
ã‚¨ãƒ³ã‚¸ãƒ³ã®ã‚ˆã†ãªæ•°å€¤è©•ä¾¡ã¯ä¸è¦ã€‚ä»£ã‚ã‚Šã«ã€Œå½¢å‹¢ãŒå‹•ã„ãŸå±€é¢ã€ã¨ç†ç”±ã‚’èª¬æ˜ã—ã¦ãã ã•ã„ã€‚
å‡ºåŠ›ã¯å¿…ãšJSONã®ã¿ã€‚

å‡ºåŠ›å½¢å¼:
{
  "summary": "ç·è©•ï¼ˆ200å­—ä»¥å†…ï¼‰",
  "turningPoints": [
    {"ply": 12, "comment": "ã“ã“ã§å½¢å‹¢ãŒå‹•ã„ãŸç†ç”±", "betterIdeas": ["å€™è£œ1","å€™è£œ2"] }
  ],
  "goodMoves": [{"ply": 20, "comment": "è‰¯ã„æ‰‹ã®ç†ç”±"}],
  "badMoves": [{"ply": 34, "comment": "ç–‘å•æ‰‹ã®ç†ç”±", "fix": "æ”¹å–„æ¡ˆ"}],
  "endgame": "çµ‚ç›¤ã®ãƒã‚¤ãƒ³ãƒˆï¼ˆ200å­—ä»¥å†…ï¼‰"
}

æ£‹è­œ(JSON):
${JSON.stringify(kifuJson)}
`;
  const text = await callGemini(prompt);
  return JSON.parse(text); // è¿”ç­”ãŒJSONå‰æ
}
</script>

</body>
</html>
