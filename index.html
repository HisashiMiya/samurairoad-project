<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>街道マップ（UX強化 + 検索改善） ※現在地はかなり精度が悪いです。ルート検索、履歴取得などに使ってください</title>

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Leaflet Routing Machine -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
  <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.min.js"></script>

  <style>

/* ===== Kaidō Panel ===== */
.kaido-panel{
  position: fixed;
  top: 12px;
  right: 12px;
  z-index: 9999;
  width: min(320px, calc(100vw - 24px));
  background: rgba(255,255,255,.96);
  border: 1px solid rgba(0,0,0,.12);
  border-radius: 12px;
  box-shadow: 0 6px 24px rgba(0,0,0,.12);
  padding: 10px 12px;
  font-size: 14px;
  backdrop-filter: blur(6px);
}
.kaido-panel__title{ font-weight: 900; margin: 4px 0 6px; }
.kaido-panel__grid{ display: grid; grid-template-columns: 1fr 1fr; gap: 6px 10px; }
.kaido-panel label{ display:flex; align-items:center; gap:8px; cursor:pointer; user-select:none; }
.btn-small{
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid rgba(0,0,0,.18);
  background:#fff;
  font-weight: 800;
  cursor:pointer;
min-height:48px;min-width:48px;}

.kaido-panel__actions{ display:flex; gap:8px; margin-top:10px; }
.kaido-panel__hint{ margin-top:8px; color:#444; font-size:12px; line-height:1.35; }
.poi-label-icon{ background:none; border:none; }
.poi-label{
  display:inline-block;
  padding: 6px 10px;
  border-radius: 999px;
  border: 2px solid #111;
  background:#fff;
  font-weight: 900;
  font-size: 12px;
  box-shadow: 0 2px 8px rgba(0,0,0,.12);
  white-space: nowrap;
}


    :root { color-scheme: light; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; margin: 14px; line-height: 1.5; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    h2 { font-size: 15px; margin: 14px 0 8px; }
    h3 { font-size: 13px; margin: 12px 0 6px; }

    .app { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 980px) { .app { grid-template-columns: 1.2fr .8fr; align-items: start; } }

    .panel { border: 1px solid rgba(0,0,0,.12); border-radius: 14px; padding: 12px; background: #fff; }
    #map { width: 100%; height: 48vh; min-height: 340px; border-radius: 14px; overflow: hidden; border: 1px solid rgba(0,0,0,.12); }

    .row { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .grow { flex: 1 1 260px; }
    .btn { padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(0,0,0,.2); background:#fff; cursor:pointer; }
    .btn:hover { background: rgba(0,0,0,.04); }
    .btnPrimary { border-color: rgba(0,90,200,.35); background: rgba(0,90,200,.04); }
    .btnDanger { border-color: rgba(200,0,0,.25); }
    .btnGhost { border-color: rgba(0,0,0,.12); background: rgba(0,0,0,.02); }
    .btnSmall { padding: 8px 10px; font-size: 12px; border-radius: 10px; }
    .pill { display:inline-flex; gap:6px; align-items:center; font-size: 12px; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(0,0,0,.18); }
    .small { font-size: 12px; opacity: .86; }
    .muted { opacity: .75; }

    input[type="text"], input[type="number"] {
      width: 100%; padding: 10px 12px; border-radius: 12px;
      border: 1px solid rgba(0,0,0,.2);
    }
    label { font-size: 12px; opacity: .9; }

    .tabs { display:flex; gap:8px; flex-wrap:wrap; margin-bottom: 10px; }
    .tab { padding: 8px 10px; border-radius: 999px; border: 1px solid rgba(0,0,0,.18); background: #fff; cursor:pointer; font-size: 12px; }
    .tab[aria-selected="true"] { border-color: rgba(0,90,200,.35); background: rgba(0,90,200,.06); }

    .section { display:none; }
    .section.isActive { display:block; }

    .kv { display: grid; grid-template-columns: 6em 1fr; gap: 4px 10px; margin: 8px 0 0; }

    .card { border:1px solid rgba(0,0,0,.12); border-radius: 14px; padding: 10px; background: rgba(0,0,0,.02); }
    .list { list-style:none; padding:0; margin:8px 0 0; }
    .list li { padding:10px; border:1px solid rgba(0,0,0,.12); border-radius: 12px; margin: 8px 0; background:#fff; }

    .searchResults { margin-top: 8px; }
    .searchResults .item { padding:10px; border:1px solid rgba(0,0,0,.12); border-radius: 12px; margin: 8px 0; background:#fff; }
    .twoCol { display:grid; grid-template-columns: 1fr; gap: 10px; }
    @media (min-width: 520px){ .twoCol { grid-template-columns: 1fr 1fr; } }

    .toast {
      position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%);
      background: rgba(0,0,0,.86); color: #fff; padding: 10px 12px;
      border-radius: 12px; font-size: 12px; max-width: min(560px, 92vw);
      display:none; z-index: 9999;
    }
    .toast.show { display:block; }

    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 11px;
      border: 1px solid rgba(255,255,255,.35); padding: 2px 6px; border-radius: 8px; margin-left: 6px; }

    details > summary { cursor:pointer; }
  
/* ==== SamuraiRoad スマホファーストUI（v1） ==== */
html, body { height: 100%; margin: 0; }
body > h1 { display:none; }
.app { height: 100vh; }
.panel { position: relative; height: 100vh; padding: 0 !important; border: none !important; }
#map { position: fixed !important; inset: 0 !important; width: 100vw !important; height: 100vh !important; }

/* Top Nav */
#topNav{
  position: fixed;
  top: 10px; left: 10px; right: 10px;
  z-index: 10000;
  display:flex; align-items:center; gap:10px;
  padding: 10px 12px;
  border-radius: 14px;
  background: rgba(255,255,255,.92);
  backdrop-filter: blur(8px);
  border: 1px solid rgba(0,0,0,.10);
}
#topNav .navMain{ flex: 1; min-width: 0; }
#topNav .navTitle{ font-weight: 900; font-size: 14px; line-height: 1.2; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
#topNav .navSub{ font-size: 12px; opacity:.75; margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
#topNav .navRight{ display:flex; flex-direction:column; gap:6px; align-items:flex-end; }
#topNav progress{ width: 120px; height: 10px; }
#btnMenu{ border:1px solid rgba(0,0,0,.15); background:#fff; border-radius: 12px; padding: 8px 10px; font-weight: 900; }

/* FAB */
#fab{
  position: fixed;
  right: 14px;
  bottom: 110px;
  z-index: 10000;
  display:flex;
  flex-direction:column;
  gap:10px;
}
.fabBtn{
  width: 52px; height: 52px;
  border-radius: 18px;
  border: 1px solid rgba(0,0,0,.12);
  background: rgba(255,255,255,.95);
  backdrop-filter: blur(8px);
  font-weight: 900;
  cursor: pointer;
}
.fabBtn:active{ transform: translateY(1px); }

/* Bottom Sheet: 既存 .row を流用 */
.panel > .row{
  position: fixed !important;
  left: 10px; right: 10px;
  bottom: 10px;
  z-index: 10000;
  border-radius: 18px !important;
  background: rgba(255,255,255,.96) !important;
  backdrop-filter: blur(8px);
  border: 1px solid rgba(0,0,0,.10);
  padding: 10px 12px !important;
  max-height: 72vh;
  overflow: auto;
  box-shadow: 0 10px 30px rgba(0,0,0,.12);
}
body.sheet-collapsed .panel > .row{
  max-height: 62px;
  overflow: hidden;
  padding-top: 6px !important;
}
.sheetHandle{
  width: 46px;
  height: 5px;
  border-radius: 999px;
  background: rgba(0,0,0,.18);
  margin: 2px auto 10px;
}

</style>
</head>

<body>
  <h1>街道マップ（ルート検索・履歴・実績）</h1>

  <div class="app">
    <section class="panel" aria-label="地図">
      <div class="row">
        <button class="btn btnGhost" type="button" id="btn-locate">現在地</button>
        <button class="btn btnGhost" type="button" id="btn-fit-both">計画＋実績を表示範囲に</button>
        <button class="btn btnGhost" type="button" id="btn-clear-all">全部クリア</button>
        <span class="small muted">地図クリックでも「出発→目的地」を設定できます</span>
      </div>

      <div id="map" role="application" aria-label="地図"></div>

<div id="topNav" aria-label="ナビゲーション">
  <div class="navMain">
    <div class="navTitle" id="navNext">次の宿場：—</div>
    <div class="navSub" id="navSub">現在地を取得中…</div>
  </div>
  <div class="navRight" aria-label="踏破率">
    <progress id="navProgress" max="100" value="0"></progress>
    <button id="btnMenu" type="button" aria-label="メニュー">メニュー</button>
  </div>
</div>

<div id="fab" aria-label="クイック操作">
  <button class="fabBtn" id="fabLocate" type="button" aria-label="現在地復帰">◎</button>
  <button class="fabBtn" id="fabRecord" type="button" aria-label="記録開始/停止">●</button>
</div>


<div id="kaidoPanel" class="kaido-panel" aria-label="五街道レイヤー切替">
  <div class="kaido-panel__title">五街道</div>
  <div class="kaido-panel__grid">
    <label><input type="checkbox" data-kaido="東海道"> 東海道</label>
    <label><input type="checkbox" data-kaido="中山道"> 中山道</label>
    <label><input type="checkbox" data-kaido="甲州街道"> 甲州街道</label>
    <label><input type="checkbox" data-kaido="日光街道"> 日光街道</label>
    <label><input type="checkbox" data-kaido="奥州街道"> 奥州街道</label>
  </div>
  <div class="kaido-panel__title" style="margin-top:10px;">表示</div>
  <div class="kaido-panel__grid">
    <label><input type="checkbox" data-poi="宿場"> 宿場（目立つ）</label>
    <label><input type="checkbox" data-poi="一里塚"> 一里塚</label>
  </div>
  <div class="kaido-panel__actions">
    <button id="btnLocate" type="button" class="btn-small">現在地（押した時だけ）</button>
    <button id="btnFitKaidou" type="button" class="btn-small">街道にズーム</button>
    <button id="btnStopGeo" type="button" class="btn-small">POI再読込</button>
  </div>
  <div class="kaido-panel__hint" id="geoStatus">※宿場・一里塚は事前GeoJSONから読み込みます（座標が入っているものだけ表示）。</div>
</div>


      <div class="row" style="margin-top:10px;">
        <span class="pill" id="pillStart">出発：未設定</span>
        <span class="pill" id="pillEnd">目的地：未設定</span>
      </div>

      <details style="margin-top:10px;">
        <summary class="small muted">ショートカット</summary>
        <div class="small muted" style="margin-top:6px;">
          ルート検索 <span class="kbd">R</span> ／ 出発リセット <span class="kbd">S</span> ／ 目的地リセット <span class="kbd">D</span> ／ 入替 <span class="kbd">X</span>
        </div>
      </details>

      <h3>現在位置</h3>
      <dl class="kv">
        <dt>緯度</dt><dd id="latitude">--</dd>
        <dt>経度</dt><dd id="longitude">--</dd>
      </dl>
    </section>

    <aside class="panel" aria-label="操作パネル">
      <div class="tabs" role="tablist" aria-label="操作タブ">
        <button class="tab" type="button" role="tab" aria-selected="true" data-tab="route">ルート</button>
        <button class="tab" type="button" role="tab" aria-selected="false" data-tab="history">履歴</button>
        <button class="tab" type="button" role="tab" aria-selected="false" data-tab="track">実績</button>
        <button class="tab" type="button" role="tab" aria-selected="false" data-tab="settings">設定</button>
      </div>

      <!-- ROUTE -->
      <section class="section isActive" id="tab-route" role="tabpanel" aria-label="ルート">
        <h2>出発／目的地の設定（検索）</h2>

        <div class="twoCol">
          <div>
            <label for="qStart">出発：住所/スポット名</label>
            <div class="row" style="margin-top:6px;">
              <input class="grow" id="qStart" type="text" list="dlStart" placeholder="例：軽井沢駅 / 坂本宿 / 上田城" />
              <datalist id="dlStart"></datalist>
              <button class="btn btnPrimary" type="button" id="btnSearchStart">検索</button>
              <button class="btn btnSmall" type="button" id="btnClearStart">クリア</button>
            </div>
            <div class="searchResults" id="resStart" aria-live="polite"></div>
          </div>

          <div>
            <label for="qEnd">目的地：住所/スポット名</label>
            <div class="row" style="margin-top:6px;">
              <input class="grow" id="qEnd" type="text" list="dlEnd" placeholder="例：追分宿 / 高崎駅 / 碓氷峠" />
              <datalist id="dlEnd"></datalist>
              <button class="btn btnPrimary" type="button" id="btnSearchEnd">検索</button>
              <button class="btn btnSmall" type="button" id="btnClearEnd">クリア</button>
            </div>
            <div class="searchResults" id="resEnd" aria-live="polite"></div>
          </div>
        </div>

        <h2>ルート検索</h2>
        <div class="row">
          <button class="btn btnGhost" type="button" id="btn-set-start-here">現在地→出発</button>
          <button class="btn btnGhost" type="button" id="btn-set-end-here">現在地→目的地</button>
          <button class="btn" type="button" id="btn-swap">出発⇄目的地</button>
        </div>

        <div class="row" style="margin-top:8px;">
          <button class="btn btnPrimary" type="button" id="btn-route">ルート検索</button>
          <button class="btn" type="button" id="btn-route-clear">ルート消去</button>
          <button class="btn" type="button" id="btn-start-reset">出発リセット</button>
          <button class="btn" type="button" id="btn-end-reset">目的地リセット</button>
        </div>

        <div class="row" style="margin-top:8px;">
          <div class="grow">
            <label for="routeName">ルート名（履歴に保存）</label>
            <input type="text" id="routeName" placeholder="例：坂本→軽井沢（旧中山道）" />
          </div>
          <button class="btn" type="button" id="btn-name-suggest">自動命名</button>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="small muted">結果</div>
          <div id="routeSummary">未検索</div>
        </div>

        <details style="margin-top:10px;">
          <summary>操作のコツ</summary>
          <ul class="small">
            <li>検索結果は「プレビュー」で位置確認→「出発/目的地にセット」が安全です。</li>
            <li>出発・目的地ピンはドラッグで微調整できます。</li>
            <li>地図クリックでも設定できます（出発→目的地の順）。</li>
          </ul>
        </details>
      </section>

      <!-- HISTORY -->
      <section class="section" id="tab-history" role="tabpanel" aria-label="履歴">
        <h2>ルート履歴</h2>
        <div class="row">
          <button class="btn" type="button" id="btn-history-refresh">更新</button>
          <button class="btn" type="button" id="btn-history-fav-only">★のみ</button>
          <button class="btn btnDanger" type="button" id="btn-history-clear">履歴を全削除</button>
        </div>
        <ul class="list" id="historyList"></ul>
      </section>

      <!-- TRACK -->
      <section class="section" id="tab-track" role="tabpanel" aria-label="実績">
        <h2>歩いたルート（実績）</h2>
        <div class="row">
          <button class="btn btnPrimary" type="button" id="btn-track-start">記録開始</button>
          <button class="btn" type="button" id="btn-track-pause">一時停止</button>
          <button class="btn" type="button" id="btn-track-resume">再開</button>
          <button class="btn" type="button" id="btn-track-stop">記録停止</button>
          <button class="btn btnDanger" type="button" id="btn-track-clear">実績クリア</button>
        </div>

        <div class="row" style="margin-top:8px;">
          <button class="btn" type="button" id="btn-gpx">GPX書き出し</button>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="small muted">統計</div>
          <div id="trackSummary">未記録</div>
          <div class="small muted" id="segmentSummary" style="margin-top:6px;"></div>
        </div>

        <details style="margin-top:10px;">
          <summary>注意事項（位置情報・実績ルート取得）</summary>
          <ul class="small">
            <li>位置情報の取得は<strong>ブラウザの許可</strong>が必要です。拒否した場合は取得できません。</li>
            <li>スマホでは<strong>HTTPS</strong>で公開していないページは位置情報が動作しない場合があります（ローカル <code>file://</code> でも制限されがちです）。</li>
            <li>連続取得（記録中）は<strong>バッテリー消費</strong>が増えます。使わないときは「記録停止」または「一時停止」を推奨します。</li>
            <li>GPS精度は環境で変わります（屋内・ビル街・山間部など）。精度が悪い点は自動で捨てる／間引く設定があります。</li>
            <li>実績ルートと履歴はこのブラウザ内（localStorage）に保存します。共有PCでは注意してください。</li>
          </ul>
        </details>
      </section>

      <!-- SETTINGS -->
      <section class="section" id="tab-settings" role="tabpanel" aria-label="設定">
        <h2>記録設定（間引き・精度）</h2>
        <div class="row" style="margin-top:8px;">
          <div class="grow">
            <label for="minMove">記録する最小移動距離（m）</label>
            <input type="number" id="minMove" min="1" step="1" />
          </div>
          <div class="grow">
            <label for="maxAcc">捨てる精度しきい値（m）</label>
            <input type="number" id="maxAcc" min="5" step="1" />
          </div>
          <button class="btn" type="button" id="btn-track-settings-save">保存</button>
        </div>

        <h2>検索履歴</h2>
        <div class="row">
          <button class="btn btnDanger" type="button" id="btn-clear-search-history">検索履歴を削除</button>
        </div>

        <h2>ジオコーディングについて</h2>
        <div class="card">
          <p class="small">
            このページは OpenStreetMap の検索（Nominatim）を直接呼び出します。大量アクセスは規約上NGになりやすいです。検索は必要な回数に留めてください。
          </p>
        </div>
      </section>
    </aside>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

<script>
(() => {
  // ===== Storage keys =====
  const STORE_ROUTE_HISTORY = "tizu_route_history_v4";
  const STORE_TRACK = "tizu_track_v4";
  const STORE_TRACK_SETTINGS = "tizu_track_settings_v3";
  const STORE_UI = "tizu_ui_state_v1";
  const STORE_SEARCH_HISTORY = "tizu_search_history_v1"; // {start:[], end:[]}

  // ===== Elements =====
  const $toast = document.getElementById("toast");

  const $lat = document.getElementById("latitude");
  const $lng = document.getElementById("longitude");
  const $pillStart = document.getElementById("pillStart");
  const $pillEnd = document.getElementById("pillEnd");

  const $btnLocate = document.getElementById("btn-locate");
  const $btnFitBoth = document.getElementById("btn-fit-both");
  const $btnClearAll = document.getElementById("btn-clear-all");

  const $qStart = document.getElementById("qStart");
  const $qEnd = document.getElementById("qEnd");
  const $dlStart = document.getElementById("dlStart");
  const $dlEnd = document.getElementById("dlEnd");
  const $btnSearchStart = document.getElementById("btnSearchStart");
  const $btnSearchEnd = document.getElementById("btnSearchEnd");
  const $resStart = document.getElementById("resStart");
  const $resEnd = document.getElementById("resEnd");
  const $btnClearStart = document.getElementById("btnClearStart");
  const $btnClearEnd = document.getElementById("btnClearEnd");

  const $btnSetStartHere = document.getElementById("btn-set-start-here");
  const $btnSetEndHere = document.getElementById("btn-set-end-here");
  const $btnSwap = document.getElementById("btn-swap");
  const $btnRoute = document.getElementById("btn-route");
  const $btnRouteClear = document.getElementById("btn-route-clear");
  const $btnStartReset = document.getElementById("btn-start-reset");
  const $btnEndReset = document.getElementById("btn-end-reset");
  const $routeSummary = document.getElementById("routeSummary");
  const $routeName = document.getElementById("routeName");
  const $btnNameSuggest = document.getElementById("btn-name-suggest");

  const $historyList = document.getElementById("historyList");
  const $btnHistoryRefresh = document.getElementById("btn-history-refresh");
  const $btnHistoryFavOnly = document.getElementById("btn-history-fav-only");
  const $btnHistoryClear = document.getElementById("btn-history-clear");

  const $btnTrackStart = document.getElementById("btn-track-start");
  const $btnTrackPause = document.getElementById("btn-track-pause");
  const $btnTrackResume = document.getElementById("btn-track-resume");
  const $btnTrackStop = document.getElementById("btn-track-stop");
  const $btnTrackClear = document.getElementById("btn-track-clear");
  const $btnGPX = document.getElementById("btn-gpx");
  const $trackSummary = document.getElementById("trackSummary");
  const $segmentSummary = document.getElementById("segmentSummary");

  const $minMove = document.getElementById("minMove");
  const $maxAcc = document.getElementById("maxAcc");
  const $btnTrackSettingsSave = document.getElementById("btn-track-settings-save");
  const $btnClearSearchHistory = document.getElementById("btn-clear-search-history");

  // Tabs
  const tabButtons = Array.from(document.querySelectorAll(".tab"));
  const sections = {
    route: document.getElementById("tab-route"),
    history: document.getElementById("tab-history"),
    track: document.getElementById("tab-track"),
    settings: document.getElementById("tab-settings"),
  };

  // ===== Utilities =====
  const nowIso = () => new Date().toISOString();
  const fmtDT = (ms) => new Date(ms).toLocaleString("ja-JP");
  const escapeHtml = (s) => String(s)
    .replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;").replaceAll("'", "&#39;");

  function showToast(msg) {
    $toast.textContent = msg;
    $toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => $toast.classList.remove("show"), 2200);
  }

  function loadJson(key, fallback) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return fallback;
      const v = JSON.parse(raw);
      return v ?? fallback;
    } catch { return fallback; }
  }
  function saveJson(key, v) { localStorage.setItem(key, JSON.stringify(v)); }

  function haversineMeters(a, b) {
    const R = 6371000;
    const toRad = (x) => x * Math.PI / 180;
    const dLat = toRad(b.lat - a.lat);
    const dLng = toRad(b.lng - a.lng);
    const lat1 = toRad(a.lat);
    const lat2 = toRad(b.lat);
    const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLng/2)**2;
    return 2 * R * Math.asin(Math.min(1, Math.sqrt(s)));
  }
  function fmtMeters(m) {
    if (!isFinite(m)) return "--";
    if (m < 1000) return `${Math.round(m)} m`;
    return `${(m/1000).toFixed(2)} km`;
  }
  function fmtSeconds(sec) {
    if (!isFinite(sec)) return "--";
    sec = Math.max(0, Math.round(sec));
    const h = Math.floor(sec / 3600);
    const r = sec % 3600;
    const m = Math.floor(r / 60);
    const s = r % 60;
    if (h > 0) return `${h}時間${m}分`;
    if (m > 0) return `${m}分${s}秒`;
    return `${s}秒`;
  }
  function fmtSpeed(mps) {
    if (!isFinite(mps) || mps <= 0) return "--";
    return `${(mps * 3.6).toFixed(1)} km/h`;
  }

  // ===== UI State =====
  let uiState = loadJson(STORE_UI, { tab: "route", start: null, end: null });
  function saveUI() { saveJson(STORE_UI, uiState); }

  // ===== Track settings =====
  const defaultSettings = { minMoveM: 10, maxAccM: 60 };
  let trackSettings = { ...defaultSettings, ...(loadJson(STORE_TRACK_SETTINGS, {})) };
  function applySettingsToUI() {
    $minMove.value = String(trackSettings.minMoveM);
    $maxAcc.value = String(trackSettings.maxAccM);
  }
  function saveSettingsFromUI() {
    const minMoveM = Math.max(1, Number($minMove.value || defaultSettings.minMoveM));
    const maxAccM = Math.max(5, Number($maxAcc.value || defaultSettings.maxAccM));
    trackSettings = { minMoveM, maxAccM };
    saveJson(STORE_TRACK_SETTINGS, trackSettings);
    showToast("記録設定を保存しました");
  }

  // ===== Search history =====
  function loadSearchHistory() {
    const v = loadJson(STORE_SEARCH_HISTORY, { start: [], end: [] });
    v.start = Array.isArray(v.start) ? v.start : [];
    v.end = Array.isArray(v.end) ? v.end : [];
    return v;
  }
  function saveSearchHistory(v) { saveJson(STORE_SEARCH_HISTORY, v); }
  function addSearchHistory(which, q) {
    const s = loadSearchHistory();
    const arr = which === "start" ? s.start : s.end;
    const v = (q || "").trim();
    if (!v) return;
    const next = [v, ...arr.filter(x => x !== v)].slice(0, 15);
    if (which === "start") s.start = next; else s.end = next;
    saveSearchHistory(s);
    renderSearchDatalist();
  }
  function renderSearchDatalist() {
    const s = loadSearchHistory();
    $dlStart.innerHTML = s.start.map(x => `<option value="${escapeHtml(x)}"></option>`).join("");
    $dlEnd.innerHTML = s.end.map(x => `<option value="${escapeHtml(x)}"></option>`).join("");
  }

  // ===== Map =====
  const map = L.map("map", { zoomControl: true });
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);
  map.setView([35.681236, 139.767125], 12);

  

  // ===== 五街道：ルート＋宿場表示 =====
  const KAIDO_STATIONS = {"東海道": [{"no": 1, "name": "日本橋", "city": "東京都中央区"}, {"no": 2, "name": "品川宿", "city": "東京都品川区"}, {"no": 3, "name": "川崎宿", "city": "神奈川県川崎市"}, {"no": 4, "name": "神奈川宿", "city": "横浜市神奈川区"}, {"no": 5, "name": "保土ヶ谷宿", "city": "横浜市保土ヶ谷区"}, {"no": 6, "name": "戸塚宿", "city": "横浜市戸塚区"}, {"no": 7, "name": "藤沢宿", "city": "神奈川県藤沢市"}, {"no": 8, "name": "平塚宿", "city": "神奈川県平塚市"}, {"no": 9, "name": "大磯宿", "city": "神奈川県大磯町"}, {"no": 10, "name": "小田原宿", "city": "神奈川県小田原市"}, {"no": 11, "name": "箱根宿", "city": "神奈川県箱根町"}, {"no": 12, "name": "三島宿", "city": "静岡県三島市"}, {"no": 13, "name": "沼津宿", "city": "静岡県沼津市"}, {"no": 14, "name": "原宿", "city": "静岡県沼津市"}, {"no": 15, "name": "吉原宿", "city": "静岡県富士市"}, {"no": 16, "name": "蒲原宿", "city": "静岡市清水区"}, {"no": 17, "name": "由比宿", "city": "静岡市清水区"}, {"no": 18, "name": "興津宿", "city": "静岡市清水区"}, {"no": 19, "name": "江尻宿", "city": "静岡市清水区"}, {"no": 20, "name": "府中宿", "city": "静岡市葵区"}, {"no": 21, "name": "丸子宿", "city": "静岡市駿河区"}, {"no": 22, "name": "岡部宿", "city": "静岡県藤枝市"}, {"no": 23, "name": "藤枝宿", "city": "静岡県藤枝市"}, {"no": 24, "name": "島田宿", "city": "静岡県島田市"}, {"no": 25, "name": "金谷宿", "city": "静岡県島田市"}, {"no": 26, "name": "日坂宿", "city": "静岡県掛川市"}, {"no": 27, "name": "掛川宿", "city": "静岡県掛川市"}, {"no": 28, "name": "袋井宿", "city": "静岡県袋井市"}, {"no": 29, "name": "見付宿", "city": "静岡県磐田市"}, {"no": 30, "name": "浜松宿", "city": "静岡県浜松市"}, {"no": 31, "name": "舞阪宿", "city": "静岡県湖西市"}, {"no": 32, "name": "新居宿", "city": "静岡県湖西市"}, {"no": 33, "name": "白須賀宿", "city": "静岡県湖西市"}, {"no": 34, "name": "二川宿", "city": "愛知県豊橋市"}, {"no": 35, "name": "吉田宿", "city": "愛知県豊橋市"}, {"no": 36, "name": "御油宿", "city": "愛知県豊川市"}, {"no": 37, "name": "赤坂宿", "city": "愛知県豊川市"}, {"no": 38, "name": "藤川宿", "city": "愛知県岡崎市"}, {"no": 39, "name": "岡崎宿", "city": "愛知県岡崎市"}, {"no": 40, "name": "池鯉鮒宿", "city": "愛知県知立市"}, {"no": 41, "name": "鳴海宿", "city": "名古屋市緑区"}, {"no": 42, "name": "宮宿", "city": "名古屋市熱田区"}, {"no": 43, "name": "桑名宿", "city": "三重県桑名市"}, {"no": 44, "name": "四日市宿", "city": "三重県四日市市"}, {"no": 45, "name": "石薬師宿", "city": "三重県鈴鹿市"}, {"no": 46, "name": "庄野宿", "city": "三重県鈴鹿市"}, {"no": 47, "name": "亀山宿", "city": "三重県亀山市"}, {"no": 48, "name": "関宿", "city": "三重県亀山市"}, {"no": 49, "name": "坂下宿", "city": "三重県亀山市"}, {"no": 50, "name": "土山宿", "city": "滋賀県甲賀市"}, {"no": 51, "name": "水口宿", "city": "滋賀県甲賀市"}, {"no": 52, "name": "石部宿", "city": "滋賀県湖南市"}, {"no": 53, "name": "草津宿", "city": "滋賀県草津市"}, {"no": null, "name": "三条大橋", "city": "京都市東山区"}], "中山道": [{"no": 0, "name": "日本橋", "city": ""}, {"no": 1, "name": "板橋宿", "city": ""}, {"no": 2, "name": "蕨宿", "city": ""}, {"no": 3, "name": "浦和宿", "city": ""}, {"no": 4, "name": "大宮宿", "city": ""}, {"no": 5, "name": "上尾宿", "city": ""}, {"no": 6, "name": "桶川宿", "city": ""}, {"no": 7, "name": "鴻巣宿", "city": ""}, {"no": 8, "name": "熊谷宿", "city": ""}, {"no": 9, "name": "深谷宿", "city": ""}, {"no": 10, "name": "本庄宿", "city": ""}, {"no": 11, "name": "新町宿", "city": ""}, {"no": 12, "name": "倉賀野宿", "city": ""}, {"no": 13, "name": "高崎宿", "city": ""}, {"no": 14, "name": "板鼻宿", "city": ""}, {"no": 15, "name": "安中宿", "city": ""}, {"no": 16, "name": "松井田宿", "city": ""}, {"no": 17, "name": "坂本宿", "city": ""}, {"no": 18, "name": "軽井沢宿", "city": ""}, {"no": 19, "name": "沓掛宿", "city": ""}, {"no": 20, "name": "追分宿", "city": ""}, {"no": 21, "name": "小田井宿", "city": ""}, {"no": 22, "name": "岩村田宿", "city": ""}, {"no": 23, "name": "塩名田宿", "city": ""}, {"no": 24, "name": "八幡宿", "city": ""}, {"no": 25, "name": "望月宿", "city": ""}, {"no": 26, "name": "芦田宿", "city": ""}, {"no": 27, "name": "長久保宿", "city": ""}, {"no": 28, "name": "和田宿", "city": ""}, {"no": 29, "name": "下諏訪宿", "city": ""}, {"no": 30, "name": "塩尻宿", "city": ""}, {"no": 31, "name": "洗馬宿", "city": ""}, {"no": 32, "name": "本山宿", "city": ""}, {"no": 33, "name": "贄川宿", "city": ""}, {"no": 34, "name": "奈良井宿", "city": ""}, {"no": 35, "name": "藪原宿", "city": ""}, {"no": 36, "name": "宮ノ越宿", "city": ""}, {"no": 37, "name": "福島宿", "city": ""}, {"no": 38, "name": "上松宿", "city": ""}, {"no": 39, "name": "須原宿", "city": ""}, {"no": 40, "name": "野尻宿", "city": ""}, {"no": 41, "name": "三留野宿", "city": ""}, {"no": 42, "name": "妻籠宿", "city": ""}, {"no": 43, "name": "馬籠宿", "city": ""}, {"no": 44, "name": "落合宿", "city": ""}, {"no": 45, "name": "中津川宿", "city": ""}, {"no": 46, "name": "大井宿", "city": ""}, {"no": 47, "name": "大湫宿", "city": ""}, {"no": 48, "name": "細久手宿", "city": ""}, {"no": 49, "name": "御嶽宿", "city": ""}, {"no": 50, "name": "伏見宿", "city": ""}, {"no": 51, "name": "太田宿", "city": ""}, {"no": 52, "name": "鵜沼宿", "city": ""}, {"no": 53, "name": "加納宿", "city": ""}, {"no": 54, "name": "河渡宿", "city": ""}, {"no": 55, "name": "美江寺宿", "city": ""}, {"no": 56, "name": "赤坂宿", "city": ""}, {"no": 57, "name": "垂井宿", "city": ""}, {"no": 58, "name": "関ヶ原宿", "city": ""}, {"no": 59, "name": "今須宿", "city": ""}, {"no": 60, "name": "柏原宿", "city": ""}, {"no": 61, "name": "醒井宿", "city": ""}, {"no": 62, "name": "番場宿", "city": ""}, {"no": 63, "name": "鳥居本宿", "city": ""}, {"no": 64, "name": "高宮宿", "city": ""}, {"no": 65, "name": "愛知川宿", "city": ""}, {"no": 66, "name": "武佐宿", "city": ""}, {"no": 67, "name": "守山宿", "city": ""}, {"no": 68, "name": "草津宿", "city": ""}, {"no": 69, "name": "大津宿", "city": ""}, {"no": 70, "name": "三条大橋", "city": ""}], "甲州街道": [{"no": 0, "name": "日本橋", "city": "東京都中央区"}, {"no": 1, "name": "内藤新宿", "city": "東京都新宿区"}, {"no": 2, "name": "下高井戸宿", "city": "東京都杉並区"}, {"no": 3, "name": "上高井戸宿", "city": "東京都杉並区"}, {"no": 4, "name": "国領宿", "city": "東京都調布市"}, {"no": 5, "name": "下布田宿", "city": "東京都調布市"}, {"no": 6, "name": "上布田宿", "city": "東京都調布市"}, {"no": 7, "name": "下石原宿", "city": "東京都調布市"}, {"no": 8, "name": "上石原宿", "city": "東京都調布市"}, {"no": 9, "name": "府中宿", "city": "東京都府中市"}, {"no": 10, "name": "日野宿", "city": "東京都日野市"}, {"no": 11, "name": "八王子宿", "city": "東京都八王子市"}, {"no": 12, "name": "駒木野宿", "city": "東京都八王子市"}, {"no": 13, "name": "小仏宿", "city": "東京都八王子市"}, {"no": 14, "name": "小原宿", "city": "神奈川県相模原市"}, {"no": 15, "name": "与瀬宿", "city": "神奈川県相模原市"}, {"no": 16, "name": "吉野宿", "city": "神奈川県相模原市"}, {"no": 17, "name": "関野宿", "city": "神奈川県相模原市"}, {"no": 18, "name": "上野原宿", "city": "山梨県上野原市"}, {"no": 19, "name": "鶴川宿", "city": "山梨県上野原市"}, {"no": 20, "name": "野田尻宿", "city": "山梨県上野原市"}, {"no": 21, "name": "犬目宿", "city": "山梨県上野原市"}, {"no": 22, "name": "下鳥沢宿", "city": "山梨県大月市"}, {"no": 23, "name": "上鳥沢宿", "city": "山梨県大月市"}, {"no": 24, "name": "猿橋宿", "city": "山梨県大月市"}, {"no": 25, "name": "駒橋宿", "city": "山梨県大月市"}, {"no": 26, "name": "大月宿", "city": "山梨県大月市"}, {"no": 27, "name": "下花咲宿", "city": "山梨県大月市"}, {"no": 28, "name": "上花咲宿", "city": "山梨県大月市"}, {"no": 29, "name": "下初狩宿", "city": "山梨県大月市"}, {"no": 30, "name": "中初狩宿", "city": "山梨県大月市"}, {"no": 31, "name": "白野宿", "city": "山梨県大月市"}, {"no": 32, "name": "黒野田宿", "city": "山梨県大月市"}, {"no": 33, "name": "駒飼宿", "city": "山梨県甲州市"}, {"no": 34, "name": "鶴瀬宿", "city": "山梨県甲州市"}, {"no": 35, "name": "勝沼宿", "city": "山梨県甲州市"}, {"no": 36, "name": "栗原宿", "city": "山梨県山梨市"}, {"no": 37, "name": "石和宿", "city": "山梨県笛吹市"}, {"no": 38, "name": "甲府柳町宿", "city": "山梨県甲府市"}, {"no": 39, "name": "韮崎宿", "city": "山梨県韮崎市"}, {"no": 40, "name": "台ヶ原宿", "city": "山梨県北杜市"}, {"no": 41, "name": "教来石宿", "city": "山梨県北杜市"}, {"no": 42, "name": "蔦木宿", "city": "長野県富士見町"}, {"no": 43, "name": "金沢宿", "city": "長野県茅野市"}, {"no": 44, "name": "上諏訪宿", "city": "長野県諏訪市"}, {"no": null, "name": "下諏訪宿", "city": "長野県下諏訪町"}], "日光街道": [{"no": 0, "name": "日本橋", "city": "東京都中央区"}, {"no": 1, "name": "千住宿", "city": "東京都足立区"}, {"no": 2, "name": "草加宿", "city": "埼玉県草加市"}, {"no": 3, "name": "越ヶ谷宿", "city": "埼玉県越谷市"}, {"no": 4, "name": "粕壁宿", "city": "埼玉県春日部市"}, {"no": 5, "name": "杉戸宿", "city": "埼玉県北葛飾郡杉戸町"}, {"no": 6, "name": "幸手宿", "city": "埼玉県幸手市"}, {"no": 7, "name": "栗橋宿", "city": "埼玉県久喜市"}, {"no": 8, "name": "中田宿", "city": "茨城県古河市"}, {"no": 9, "name": "古河宿", "city": "茨城県古河市"}, {"no": 10, "name": "野木宿", "city": "栃木県下都賀郡野木町"}, {"no": 11, "name": "間々田宿", "city": "栃木県小山市"}, {"no": 12, "name": "小山宿", "city": "栃木県小山市"}, {"no": 13, "name": "新田宿", "city": "栃木県小山市"}, {"no": 14, "name": "小金井宿", "city": "栃木県下野市"}, {"no": 15, "name": "石橋宿", "city": "栃木県下野市"}, {"no": 16, "name": "雀宮宿", "city": "栃木県宇都宮市"}, {"no": 17, "name": "宇都宮宿", "city": "栃木県宇都宮市"}, {"no": 18, "name": "下徳次郎宿", "city": "栃木県宇都宮市"}, {"no": 19, "name": "中徳次郎宿", "city": "栃木県宇都宮市"}, {"no": 20, "name": "上徳次郎宿", "city": "栃木県宇都宮市"}, {"no": 21, "name": "大沢宿", "city": "栃木県日光市"}, {"no": 22, "name": "今市宿", "city": "栃木県日光市"}, {"no": 23, "name": "鉢石宿", "city": "栃木県日光市"}, {"no": 24, "name": "日光神橋", "city": "栃木県日光市"}], "奥州街道": [{"no": 0, "name": "日本橋", "city": "東京都中央区"}, {"no": 1, "name": "千住宿", "city": "東京都足立区"}, {"no": 2, "name": "草加宿", "city": "埼玉県草加市"}, {"no": 3, "name": "越ヶ谷宿", "city": "埼玉県越谷市"}, {"no": 4, "name": "粕壁宿", "city": "埼玉県春日部市"}, {"no": 5, "name": "杉戸宿", "city": "埼玉県北葛飾郡杉戸町"}, {"no": 6, "name": "幸手宿", "city": "埼玉県幸手市"}, {"no": 7, "name": "栗橋宿", "city": "埼玉県久喜市"}, {"no": 8, "name": "中田宿", "city": "茨城県古河市"}, {"no": 9, "name": "古河宿", "city": "茨城県古河市"}, {"no": 10, "name": "野木宿", "city": "栃木県下都賀郡野木町"}, {"no": 11, "name": "間々田宿", "city": "栃木県小山市"}, {"no": 12, "name": "小山宿", "city": "栃木県小山市"}, {"no": 13, "name": "新田宿", "city": "栃木県小山市"}, {"no": 14, "name": "小金井宿", "city": "栃木県下野市"}, {"no": 15, "name": "石橋宿", "city": "栃木県下野市"}, {"no": 16, "name": "雀宮宿", "city": "栃木県宇都宮市"}, {"no": 17, "name": "宇都宮宿", "city": "栃木県宇都宮市"}, {"no": 18, "name": "白沢宿", "city": "栃木県宇都宮市"}, {"no": 19, "name": "氏家宿", "city": "栃木県さくら市"}, {"no": 20, "name": "喜連川宿", "city": "栃木県さくら市"}, {"no": 21, "name": "佐久山宿", "city": "栃木県大田原市"}, {"no": 22, "name": "大田原宿", "city": "栃木県大田原市"}, {"no": 23, "name": "鍋掛宿", "city": "栃木県那須塩原市"}, {"no": 24, "name": "越堀宿", "city": "栃木県那須塩原市"}, {"no": 25, "name": "芦野宿", "city": "栃木県那須郡那須町"}, {"no": 26, "name": "白坂宿", "city": "福島県白河市"}, {"no": 27, "name": "白河宿", "city": "福島県白河市"}]};


  const kaidoLayers = {};
  const stationLayers = {};
  const ichirizukaLayers = {};

  // ルート・宿場の索引（次の宿場判定用）
  const routeCache = {};   // route -> { latlngs: L.LatLng[], cum: number[] }
  const stationIndex = {}; // route -> [{route,type,name,no,lat,lng}]
  const dataErrors = {}; // route -> true if load failed

  const ROUTES = {
    "東海道": "data/tokaido_strict.geojson",
    "中山道": "data/nakaendo_route.geojson",
    "甲州街道": "data/koshu_route.geojson",
    "日光街道": "data/nikko_route.geojson",
    "奥州街道": "data/oshu_route.geojson"
  };

  function styleRoute(feature){
    const p = feature && feature.properties || {};
    if (p.style === "sea") return { weight: 4, opacity: 0.9, dashArray: "6 6" };
    return { weight: 5, opacity: 0.9 };
  }

  
  // --- ルートキャッシュ構築（次の宿場判定・道なり距離用） ---
  function extractPrimaryLineLatLngs(geojson){
    // GeoJSON FeatureCollection から LineString / MultiLineString を抽出し、最長のラインを採用
    const lines = [];
    const feats = (geojson && geojson.features) ? geojson.features : [];
    for (const f of feats){
      const g = f && f.geometry;
      if (!g) continue;
      if (g.type === "LineString" && Array.isArray(g.coordinates)){
        lines.push(g.coordinates);
      } else if (g.type === "MultiLineString" && Array.isArray(g.coordinates)){
        for (const part of g.coordinates) lines.push(part);
      }
    }
    if (!lines.length) return [];
    let best = lines[0];
    for (const l of lines) if ((l?.length||0) > (best?.length||0)) best = l;
    return best.map(c=>L.latLng(c[1], c[0]));
  }

  function buildRouteCache(routeName, geojson){
    const latlngs = extractPrimaryLineLatLngs(geojson);
    if (!latlngs.length) return;
    const cum = [0];
    for (let i=1;i<latlngs.length;i++){
      cum[i] = cum[i-1] + latlngs[i-1].distanceTo(latlngs[i]); // Leaflet内蔵（概算m）
    }
    routeCache[routeName] = { latlngs, cum };
  }

  function projectToSegmentMeters(p, a, b){
    // p,a,b: L.LatLng  / 近似平面で投影（短距離前提）
    // returns { t, proj: L.LatLng, dist: meters }
    const lat0 = (a.lat + b.lat) * 0.5;
    const kx = 111320 * Math.cos(lat0 * Math.PI/180);
    const ky = 110540;
    const ax = (a.lng) * kx, ay = (a.lat) * ky;
    const bx = (b.lng) * kx, by = (b.lat) * ky;
    const px = (p.lng) * kx, py = (p.lat) * ky;

    const abx = bx-ax, aby = by-ay;
    const apx = px-ax, apy = py-ay;
    const ab2 = abx*abx + aby*aby || 1e-9;
    let t = (apx*abx + apy*aby) / ab2;
    if (t<0) t=0; if (t>1) t=1;
    const qx = ax + abx*t, qy = ay + aby*t;
    const dx = px-qx, dy = py-qy;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const proj = L.latLng(qy/ky, qx/kx);
    return { t, proj, dist };
  }

  function snapToRoute(routeName, hereLL){
    const c = routeCache[routeName];
    if (!c || !c.latlngs || c.latlngs.length < 2) return null;
    let best = null;
    for (let i=0;i<c.latlngs.length-1;i++){
      const a = c.latlngs[i], b = c.latlngs[i+1];
      const pr = projectToSegmentMeters(hereLL, a, b);
      if (!best || pr.dist < best.dist){
        // 距離S（ルート始点からの道なり距離）
        const segLen = a.distanceTo(b);
        const s = c.cum[i] + segLen * pr.t;
        best = { route: routeName, i, s, ...pr };
      }
    }
    return best;
  }

  function routeSForPoint(routeName, pointLL){
    // pointLL をルートにスナップし、始点からのSを返す
    const sn = snapToRoute(routeName, pointLL);
    return sn ? sn.s : null;
  
  function latLngAtRouteS(routeName, s){
    const c = routeCache[routeName];
    if (!c || !c.latlngs || c.latlngs.length < 2) return null;
    const total = c.cum[c.cum.length-1];
    if (!(s>=0) || total<=0) return null;
    // clamp
    if (s <= 0) return c.latlngs[0];
    if (s >= total) return c.latlngs[c.latlngs.length-1];
    // find segment (linear scan; route points are not huge. can optimize later)
    let i = 0;
    while (i < c.cum.length-1 && c.cum[i+1] < s) i++;
    const s0 = c.cum[i], s1 = c.cum[i+1];
    const t = (s - s0) / (s1 - s0);
    const a = c.latlngs[i], b = c.latlngs[i+1];
    return L.latLng(a.lat + (b.lat-a.lat)*t, a.lng + (b.lng-a.lng)*t);
  }

  function synthesizePoiPointIfMissing(routeName, props, maxNo){
    // プロパティnoに基づき、ルートの始点〜終点を等分して仮配置（参加型前提の暫定）
    // ルートにsnakeしても「前方判定」は安定する。精度は後で修正提案で上げる。
    const no = Number(props?.no);
    if (!Number.isFinite(no) || !Number.isFinite(maxNo) || maxNo <= 0) return null;
    const c = routeCache[routeName];
    if (!c || !c.cum || c.cum.length < 2) return null;
    const total = c.cum[c.cum.length-1];
    const s = total * Math.min(Math.max(no / maxNo, 0), 1);
    return latLngAtRouteS(routeName, s);
  }
}

  function calculateRouteDistance(currentLatLng, routeName, nextStationLatLng){
    // 道なり距離（m）。ルートキャッシュがない場合は直線距離でフォールバック
    const hereLL = L.latLng(currentLatLng.lat, currentLatLng.lng);
    const stLL = L.latLng(nextStationLatLng.lat, nextStationLatLng.lng);
    const snHere = snapToRoute(routeName, hereLL);
    const sHere = snHere ? snHere.s : null;
    const sSt = routeSForPoint(routeName, stLL);

    if (sHere == null || sSt == null) return hereLL.distanceTo(stLL);

    const d = sSt - sHere;
    return (d >= 0) ? d : hereLL.distanceTo(stLL);
  }

  function getNextStation(routeName, hereLL){
    const list = stationIndex[routeName] || [];
    if (!list.length) return null;
    const reachedNo = parseInt(localStorage.getItem(`lastReachedNo:${routeName}`) || "0", 10) || 0;

    const snHere = snapToRoute(routeName, hereLL);
    const sHere = snHere ? snHere.s : null;

    // no（順序）がある場合は「近傍宿場のno」から前方を選ぶ（軽い）
    const hasNo = list.some(x=>x.no != null);
    const listByNo = hasNo ? list.filter(s=>s.no!=null && s.no > reachedNo) : list;

    if (hasNo){
      // 到達済みnoより先だけを対象（逆走時のバタつき防止）
      if (listByNo.length){
        if (sHere != null){
          let bestNo = null;
          for (const st of listByNo){
            const s = routeSForPoint(routeName, L.latLng(st.lat, st.lng));
            if (s == null) continue;
            const d = s - sHere;
            if (d < 5) continue;
            if (!bestNo || d < bestNo.d) bestNo = { ...st, d };
          }
          if (bestNo) return bestNo;
        }
        // Sが取れない場合は、最小noを次にする
        let minNo = null;
        for (const st of listByNo){
          if (minNo == null || st.no < minNo.no) minNo = st;
        }
        if (minNo) return minNo;
      }
      // reachedNoが末尾を超えた等は、後続のS判定へフォールバック
    }

    // 精度版：S（ルート距離）で前方最小を選ぶ
    if (sHere != null){
      let best = null;
      for (const st of list){
        const s = routeSForPoint(routeName, L.latLng(st.lat, st.lng));
        if (s == null) continue;
        const d = s - sHere;
        if (d < 5) continue; // ほぼ同地点/通過済み扱い
        if (!best || d < best.d) best = { ...st, d };
      }
      if (best) return best;
    }

    // フォールバック：直線最寄り
    let best2 = null;
    for (const st of list){
      const d = hereLL.distanceTo(L.latLng(st.lat, st.lng));
      if (!best2 || d < best2.d) best2 = { ...st, d };
    }
    return best2;
  }

  // --- スタンプ判定（簡易：半径＋精度＋滞在） ---
  const stampState = { inSince: null, key: null };
  function maybeStamp(routeName, station, hereLL, accM){
    if (!station) return;
    if (accM == null || accM > 30) { stampState.inSince = null; stampState.key = null; return; }
    const d = hereLL.distanceTo(L.latLng(station.lat, station.lng));
    if (d > 50) { stampState.inSince = null; stampState.key = null; return; }

    const key = `reached:${routeName}:${(station.no!=null?station.no:station.name)}`;
    if (localStorage.getItem(key) === "1") return;

    const now = Date.now();
    if (stampState.key !== key){
      stampState.key = key;
      stampState.inSince = now;
      return;
    }
    if (stampState.inSince && (now - stampState.inSince) >= 15000){
      localStorage.setItem(key, "1");
      // 到達noの永続化（次回以降の前方判定に利用）
      if (station.no != null){
        const lk = `lastReachedNo:${routeName}`;
        const prev = parseInt(localStorage.getItem(lk) || "0", 10) || 0;
        if (station.no > prev) localStorage.setItem(lk, String(station.no));
      }
      try { showToast(`${station.name} に到達！`); } catch(e){}
      stampState.inSince = null;
    }
  }
function ensureRoute(name){
    if (kaidoLayers[name]) return kaidoLayers[name];
    kaidoLayers[name] = L.geoJSON(null, { style: styleRoute });
    const routeFile = (name==="中山道") ? "data/nakaendo_strict.geojson" : ROUTES[name];
    fetch(routeFile).then(r=>{
      if(!r.ok) throw new Error("route not found");
      return r.json();
    }).catch(()=>fetch(ROUTES[name]).then(r=>r.json()))
    .then(j=>{
      buildRouteCache(name, j);
      kaidoLayers[name].addData(j);
      if (!window.__kaidoAutoFitDone && enabledRoutes && enabledRoutes.size === 1) {
        window.__kaidoAutoFitDone = true;
        try { map.fitBounds(kaidoLayers[name].getBounds(), { padding:[30,30] }); } catch(e){}
      }
    }).catch(e=>{ dataErrors[name]=true; console.warn(e); });
    return kaidoLayers[name];
  }

  function makeLabelIcon(text){
    return L.divIcon({
      className: "poi-label-icon",
      html: `<div class="poi-label">${escapeHtml(text)}</div>`,
      iconSize: null
    });
  }

  function ensureStationLayer(route){
    if (!stationLayers[route]) stationLayers[route] = L.layerGroup();
    return stationLayers[route];
  }

  // ---- 現在地：ロード時に取得しない（ボタン押下のみ） ----
  function locateNow(){
    if (!navigator.geolocation) { alert("この端末では位置情報が利用できません。"); return; }
    navigator.geolocation.getCurrentPosition(
      (pos)=>{
        const lat = pos.coords.latitude, lng = pos.coords.longitude;
        if (typeof setCurrentPosition === "function") {
          setCurrentPosition(lat, lng, pos.coords.accuracy);
        } else {
          if (window.__currentMarker) map.removeLayer(window.__currentMarker);
          window.__currentMarker = L.circleMarker([lat,lng], { radius:9, weight:2, opacity:0.9, fillOpacity:0.25 }).addTo(map).bindPopup("現在地");
        }
        map.setView([lat,lng], Math.max(map.getZoom(), 15));
      },
      (err)=>alert("現在地取得に失敗しました: " + err.message),
      { enableHighAccuracy:true, timeout:12000, maximumAge:0 }
    );
  }

  // ---- 宿場・一里塚：事前JSON（GeoJSON）を読み込む ----
  // ※外部ジオコーディングは行いません。表示ONのときだけ読み込みます。
  const POI_FILES = {
    "東海道": "data/tokaido_poi.geojson",
    "中山道": "data/nakaendo_poi.geojson",
    "甲州街道": "data/koshu_poi.geojson",
    "日光街道": "data/nikko_poi.geojson",
    "奥州街道": "data/oshu_poi.geojson"
  };

  const poiLoaded = {}; // route -> boolean

  function addStationFeature(route, p, g){
    const layer = ensureStationLayer(route);
    const name = p.name || "宿場";
    const no = (p.no != null) ? Number(p.no) : null;
    const ll = L.latLng(g.coordinates[1], g.coordinates[0]);
    const m = L.marker(ll, { icon: makeLabelIcon(name), title: name });
    // 後段の「次の宿場」判定・スタンプ判定で使うメタ情報
    m.__poi = { route, type: "宿場", name, no, lat: ll.lat, lng: ll.lng };

    const body = `<b>${escapeHtml(name)}</b><br>` +
                 (p.no != null ? `No: ${escapeHtml(String(p.no))}<br>` : "") +
                 `街道: ${escapeHtml(route)}`;
    m.bindPopup(body);
    layer.addLayer(m);

    // stationIndex へも保持（表示レイヤーのON/OFFに影響されない）
    if (!stationIndex[route]) stationIndex[route] = [];
    stationIndex[route].push(m.__poi);
    // no が入っていれば順序でソート
    stationIndex[route].sort((a,b)=>{
      if (a.no == null && b.no == null) return 0;
      if (a.no == null) return 1;
      if (b.no == null) return -1;
      return a.no - b.no;
    });
  }

  function addIchirizukaFeature(route, p, g){
    if (!ichirizukaLayers[route]) ichirizukaLayers[route] = L.layerGroup();
    const layer = ichirizukaLayers[route];
    const name = p.name || "一里塚";
    const c = L.circleMarker([g.coordinates[1], g.coordinates[0]], { radius: 6, weight: 2, opacity: 0.9, fillOpacity: 0.25 });
    c.bindPopup(`<b>${escapeHtml(name)}</b><br>街道: ${escapeHtml(route)}`);
    layer.addLayer(c);
  }

  function loadPoi(route){
    if (poiLoaded[route]) return;
    poiLoaded[route] = true;
    const file = POI_FILES[route];
    fetch(file).then(r=>r.json()).then(fc=>{
      const st = ensureStationLayer(route); st.clearLayers();
      stationIndex[route] = [];
      if (ichirizukaLayers[route]) ichirizukaLayers[route].clearLayers();
      (const features = (fc.features||[]);
      // no の最大値（等分仮配置に使用）
      const maxNo = (features.reduce((mx,f)=>Math.max(mx, Number(f?.properties?.no)), -Infinity));
      features.forEach(f=>{
        const p = f.properties || {};
        let g = f.geometry;
        if (!g || g.type !== "Point"){
          // 座標が入っていないPOIは、ルートに沿って仮配置（参加型の暫定）して“動く”状態を作る
          const ll = synthesizePoiPointIfMissing(route, p, maxNo);
          if (ll){
            p._provisional = true;
            p.confidence = p.confidence || "low";
            g = { type: "Point", coordinates: [ll.lng, ll.lat] };
          } else {
            return; // まだルート未ロード等
          }
        }

        if (p.type === "宿場") addStationFeature(route, p, g);
        if (p.type === "一里塚") addIchirizukaFeature(route, p, g);
      });
      setGeoStatus(`${route}：POIを読み込みました（座標が入っているものだけ表示）`);
    }).catch(()=>{
      setGeoStatus(`${route}：POIファイルが見つかりません（${file}）`);
    });
  }

  function renderStationsForRoute(route){
    loadPoi(route);
  }
  // ---- UI ----
  const routeChecks = Array.from(document.querySelectorAll('input[data-kaido]'));
  const poiChecks = Array.from(document.querySelectorAll('input[data-poi]'));
  const btnLocate = document.getElementById("btnLocate");
  const btnStopGeo = document.getElementById("btnStopGeo");

  if (btnLocate) btnLocate.addEventListener("click", locateNow);
  if (btnStopGeo) btnStopGeo.addEventListener("click", ()=>{
    enabledRoutes.forEach(r=>{ poiLoaded[r]=false; });
    enabledRoutes.forEach(r=>{ loadPoi(r); });
  });

  const enabledRoutes = new Set();

  // 初期状態：チェックは全てOFF → 東海道だけON（画面が散らからないように）
  routeChecks.forEach(ch => { ch.checked = false; });
  enabledRoutes.clear();
  const tokaido = routeChecks.find(ch => ch.dataset.kaido === "東海道");
  if (tokaido) { tokaido.checked = true; enabledRoutes.add("東海道"); ensureRoute("東海道"); }


  function refreshVisibility(){
    enabledRoutes.forEach(r=>{ map.addLayer(ensureRoute(r)); });
    Object.keys(kaidoLayers).forEach(r=>{ if (!enabledRoutes.has(r) && map.hasLayer(kaidoLayers[r])) map.removeLayer(kaidoLayers[r]); });

    const showStations = poiChecks.find(x=>x.dataset.poi==="宿場")?.checked;
    const showIchirizuka = poiChecks.find(x=>x.dataset.poi==="一里塚")?.checked;
enabledRoutes.forEach(r=>{
      if (showStations) {
        renderStationsForRoute(r);
        map.addLayer(ensureStationLayer(r));
      } else {
        if (stationLayers[r]) map.removeLayer(stationLayers[r]);
      }

      if (showIchirizuka) {
        loadPoi(r);
        if (ichirizukaLayers[r]) map.addLayer(ichirizukaLayers[r]);
      } else {
        if (ichirizukaLayers[r]) map.removeLayer(ichirizukaLayers[r]);
      }
    });
    Object.keys(stationLayers).forEach(r=>{ if (!enabledRoutes.has(r) && map.hasLayer(stationLayers[r])) map.removeLayer(stationLayers[r]); });
  }

  routeChecks.forEach(ch=>{
    const r = ch.dataset.kaido;
    if (r==="東海道") { ch.checked=true; enabledRoutes.add(r); }
    ch.addEventListener("change", ()=>{
      if (ch.checked) enabledRoutes.add(r);
      else enabledRoutes.delete(r);
      refreshVisibility();
    });
  });

  poiChecks.forEach(ch=>ch.addEventListener("change", refreshVisibility));

  
  function fitToEnabledKaidou(){
    const boundsList = [];
    enabledRoutes.forEach(r=>{
      const lyr = kaidoLayers[r];
      if (lyr && lyr.getBounds && lyr.getLayers && lyr.getLayers().length) boundsList.push(lyr.getBounds());
      const st = stationLayers[r];
      if (st && st.getBounds && st.getLayers && st.getLayers().length) boundsList.push(st.getBounds());
    });
    if (!boundsList.length) { alert("表示中の街道がありません。"); return; }
    let b = boundsList[0];
    for (let i=1;i<boundsList.length;i++){ b = b.extend(boundsList[i]); }
    map.fitBounds(b, { padding:[30,30] });
  }
  const btnFitKaidou = document.getElementById("btnFitKaidou");
  if (btnFitKaidou) btnFitKaidou.addEventListener("click", fitToEnabledKaidou);

refreshVisibility();

let currentPos = null;
  let currentMarker = null;

  // planned markers
  let startLatLng = null;
  let endLatLng = null;
  let startMarker = null;
  let endMarker = null;

  // planned labels for pills
  let startLabel = "未設定";
  let endLabel = "未設定";

  // planned route
  let routingControl = null;
  let plannedLineLayer = null;

  // preview marker for geocode results
  let previewMarker = null;
  function showPreview(lat, lng, label) {
    if (previewMarker) previewMarker.remove();
    previewMarker = L.circleMarker([lat, lng], { radius: 9, weight: 2, opacity: 0.9, fillOpacity: 0.25 }).addTo(map);
    previewMarker.bindPopup(`プレビュー：${escapeHtml(label)}`).openPopup();
  }
  function clearPreview() {
    if (previewMarker) { previewMarker.remove(); previewMarker = null; }
  }

  // actual
  let trackWatchId = null;
  let trackIsPaused = false;
  let trackPoints = loadJson(STORE_TRACK, []);
  let actualLineLayer = null;
  let segments = [];

  function ensureActualLayer() {
    if (actualLineLayer) return;
    actualLineLayer = L.polyline([], { color: "#d33", weight: 5, opacity: 0.85 }).addTo(map);
  }
  function redrawActual() {
    ensureActualLayer();
    actualLineLayer.setLatLngs(trackPoints.map(p => [p.lat, p.lng]));
    updateTrackSummary();
  }

  function setCurrentPosition(lat, lng, accM){
    currentPos = { lat, lng, accM: (accM!=null ? Number(accM) : null) };
    updateNavOverlay(lat, lng, accM);
    $lat.textContent = lat.toFixed(6);
    $lng.textContent = lng.toFixed(6);
    if (currentMarker) currentMarker.remove();
    currentMarker = L.marker([lat, lng]).addTo(map).bindPopup("現在地");
  }

  function initMap() {
    if (!navigator.geolocation) { alert("この端末では位置情報が利用できません。"); return; }
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        setCurrentPosition(pos.coords.latitude, pos.coords.longitude, pos.coords.accuracy);
        map.setView([pos.coords.latitude, pos.coords.longitude], Math.max(map.getZoom(), 15));
        currentMarker.openPopup();
        showToast("現在地を更新しました");
      },
      () => alert("現在地を取得できませんでした。位置情報の許可をご確認ください。"),
      { enableHighAccuracy: true, timeout: 12000, maximumAge: 10000 }
    );
  }

  function setStart(latlng, label="出発") {
    startLatLng = latlng;
    startLabel = label;
    if (startMarker) startMarker.remove();
    startMarker = L.marker(latlng, { draggable: true }).addTo(map).bindPopup(label);
    startMarker.on("dragend", () => { startLatLng = startMarker.getLatLng(); updatePills(); persistStartEnd(); });
    startMarker.openPopup();
    updatePills();
    persistStartEnd();
  }
  function setEnd(latlng, label="目的地") {
    endLatLng = latlng;
    endLabel = label;
    if (endMarker) endMarker.remove();
    endMarker = L.marker(latlng, { draggable: true }).addTo(map).bindPopup(label);
    endMarker.on("dragend", () => { endLatLng = endMarker.getLatLng(); updatePills(); persistStartEnd(); });
    endMarker.openPopup();
    updatePills();
    persistStartEnd();
  }
  function resetStart() {
    startLatLng = null; startLabel = "未設定";
    if (startMarker) { startMarker.remove(); startMarker = null; }
    updatePills(); persistStartEnd();
  }
  function resetEnd() {
    endLatLng = null; endLabel = "未設定";
    if (endMarker) { endMarker.remove(); endMarker = null; }
    updatePills(); persistStartEnd();
  }
  function updatePills() {
    $pillStart.textContent = startLatLng ? `出発：${startLabel}` : "出発：未設定";
    $pillEnd.textContent = endLatLng ? `目的地：${endLabel}` : "目的地：未設定";
  }
  function persistStartEnd() {
    uiState.start = startLatLng ? { lat: startLatLng.lat, lng: startLatLng.lng, label: startLabel } : null;
    uiState.end = endLatLng ? { lat: endLatLng.lat, lng: endLatLng.lng, label: endLabel } : null;
    saveUI();
  }
  function restoreStartEnd() {
    if (uiState.start) setStart(L.latLng(uiState.start.lat, uiState.start.lng), uiState.start.label || "出発");
    if (uiState.end) setEnd(L.latLng(uiState.end.lat, uiState.end.lng), uiState.end.label || "目的地");
  }

  // map click sets start then end
  map.on("click", (e) => {
    // if user is browsing search results, a click should also clear preview (less confusing)
    clearPreview();
    if (!startLatLng) { setStart(e.latlng, "出発（クリック）"); showToast("出発を設定しました"); }
    else { setEnd(e.latlng, "目的地（クリック）"); showToast("目的地を設定しました"); }
  });

  function suggestRouteName() {
    const s = startLatLng ? startLabel.replace(/^出発：/,"").slice(0, 14) : "出発";
    const d = endLatLng ? endLabel.replace(/^目的地：/,"").slice(0, 14) : "目的地";
    $routeName.value = `${s}→${d}`;
  }

  // ===== Geocoding (Nominatim) =====
  let lastGeocodeAt = 0;
  async function nominatimSearch(q) {
    const query = (q || "").trim();
    if (!query) return [];
    const now = Date.now();
    const wait = Math.max(0, 1200 - (now - lastGeocodeAt));
    if (wait > 0) await new Promise(r => setTimeout(r, wait));
    lastGeocodeAt = Date.now();

    const url = new URL("https://nominatim.openstreetmap.org/search");
    url.searchParams.set("format", "json");
    url.searchParams.set("q", query);
    url.searchParams.set("limit", "6");
    url.searchParams.set("addressdetails", "1");
    url.searchParams.set("countrycodes", "jp");

    const res = await fetch(url.toString(), { method: "GET", headers: { "Accept": "application/json" }});
    if (!res.ok) throw new Error("search failed");
    const data = await res.json();
    return Array.isArray(data) ? data : [];
  }

  function renderSearchResults(container, results, onPick, which) {
    container.innerHTML = "";
    if (!results.length) {
      container.innerHTML = '<div class="small muted">見つかりませんでした（別の表記で試してください）</div>';
      return;
    }
    for (const r of results) {
      const lat = Number(r.lat);
      const lon = Number(r.lon);
      const name = r.display_name || "検索結果";

      const el = document.createElement("div");
      el.className = "item";
      el.innerHTML = `
        <div><strong>${escapeHtml(name)}</strong></div>
        <div class="small muted">${lat.toFixed(6)}, ${lon.toFixed(6)}</div>
        <div class="row" style="margin-top:8px;">
          <button class="btn btnPrimary btnSmall" type="button" data-act="set">セット</button>
          <button class="btn btnSmall" type="button" data-act="preview">プレビュー</button>
          <button class="btn btnSmall" type="button" data-act="zoom">地図で見る</button>
        </div>
      `;

      const setBtn = el.querySelector('button[data-act="set"]');
      const prevBtn = el.querySelector('button[data-act="preview"]');
      const zoomBtn = el.querySelector('button[data-act="zoom"]');

      prevBtn.addEventListener("click", () => {
        map.setView([lat, lon], 16);
        showPreview(lat, lon, name);
        showToast("プレビュー表示");
      });

      zoomBtn.addEventListener("click", () => {
        map.setView([lat, lon], 16);
      });

      setBtn.addEventListener("click", () => {
        clearPreview();
        onPick({ lat, lng: lon, label: name });
        addSearchHistory(which, name);
      });

      container.appendChild(el);
    }
  }

  async function doSearchStart() {
    const q = $qStart.value.trim();
    if (!q) return;
    $resStart.innerHTML = '<div class="small muted">検索中…</div>';
    try {
      const results = await nominatimSearch(q);
      renderSearchResults($resStart, results, ({lat,lng,label}) => {
        setStart(L.latLng(lat, lng), `出発：${label}`);
        map.setView([lat, lng], 16);
        showToast("出発にセットしました");
      }, "start");
      addSearchHistory("start", q);
    } catch {
      $resStart.innerHTML = '<div class="small muted">検索に失敗しました（通信状況をご確認ください）</div>';
    }
  }

  async function doSearchEnd() {
    const q = $qEnd.value.trim();
    if (!q) return;
    $resEnd.innerHTML = '<div class="small muted">検索中…</div>';
    try {
      const results = await nominatimSearch(q);
      renderSearchResults($resEnd, results, ({lat,lng,label}) => {
        setEnd(L.latLng(lat, lng), `目的地：${label}`);
        map.setView([lat, lng], 16);
        showToast("目的地にセットしました");
      }, "end");
      addSearchHistory("end", q);
    } catch {
      $resEnd.innerHTML = '<div class="small muted">検索に失敗しました（通信状況をご確認ください）</div>';
    }
  }

  // Optional: simple debounce on typing (press Enter or click search still primary)
  function debounce(fn, ms=450){
    let t=null;
    return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); };
  }
  const debouncedStart = debounce(() => { if ($qStart.value.trim().length >= 3) doSearchStart(); }, 650);
  const debouncedEnd = debounce(() => { if ($qEnd.value.trim().length >= 3) doSearchEnd(); }, 650);

  // ===== Routing / history =====
  function clearPlannedRoute() {
    if (routingControl) { map.removeControl(routingControl); routingControl = null; }
    if (plannedLineLayer) { plannedLineLayer.remove(); plannedLineLayer = null; }
    $routeSummary.textContent = "未検索";
  }

  function loadHistory() {
    const arr = loadJson(STORE_ROUTE_HISTORY, []);
    return Array.isArray(arr) ? arr : [];
  }
  function saveHistory(arr) { saveJson(STORE_ROUTE_HISTORY, arr); }
  let historyFavOnly = false;

  function routeSearch() {
    if (!startLatLng || !endLatLng) {
      showToast("出発と目的地を設定してください");
      return;
    }
    clearPlannedRoute();

    const router = L.Routing.osrmv1({ serviceUrl: "https://router.project-osrm.org/route/v1" });

    routingControl = L.Routing.control({
      waypoints: [startLatLng, endLatLng],
      router,
      addWaypoints: false,
      draggableWaypoints: true,
      fitSelectedRoutes: true,
      show: false,
      lineOptions: { styles: [{ color: "#2b7", opacity: 0.85, weight: 6 }] }
    }).addTo(map);

    routingControl.on("routesfound", (ev) => {
      const r = ev.routes && ev.routes[0];
      if (!r) return;

      const distance = r.summary.totalDistance;
      const time = r.summary.totalTime;
      const coords = (r.coordinates || []).map(c => ({ lat: c.lat, lng: c.lng }));

      plannedLineLayer = L.polyline(coords.map(p => [p.lat, p.lng]), { color: "#2b7", weight: 6, opacity: 0.85 }).addTo(map);

      const name = ($routeName.value || "").trim() || `${startLabel.replace(/^出発：/,"")}→${endLabel.replace(/^目的地：/,"")}`;
      const id = crypto?.randomUUID ? crypto.randomUUID() : String(Date.now());

      const routeObj = {
        id, name, favorite: false,
        createdAt: Date.now(),
        start: { lat: startLatLng.lat, lng: startLatLng.lng, label: startLabel },
        end: { lat: endLatLng.lat, lng: endLatLng.lng, label: endLabel },
        summary: { distance, time },
        coords
      };

      $routeSummary.innerHTML =
        `計画：<strong>${escapeHtml(name)}</strong><br>` +
        `距離 <strong>${fmtMeters(distance)}</strong> / 時間 <strong>${fmtSeconds(time)}</strong> ` +
        `<span class="pill">${fmtDT(routeObj.createdAt)}</span>`;

      const history = loadHistory();
      history.unshift(routeObj);
      saveHistory(history.slice(0, 80));
      renderHistory();
      fitPlanAndActual();
      showToast("ルートを保存しました");
    });

    routingControl.on("routingerror", () => {
      showToast("ルート検索に失敗しました");
      clearPlannedRoute();
    });
  }

  function renderHistory() {
    const hist = loadHistory();
    const items = historyFavOnly ? hist.filter(h => !!h.favorite) : hist;

    $historyList.innerHTML = "";
    if (items.length === 0) {
      $historyList.innerHTML = `<li class="small muted">${historyFavOnly ? "★が付いた履歴がありません。" : "履歴がありません。"}</li>`;
      return;
    }

    for (const h of items.slice(0, 80)) {
      const dist = h?.summary?.distance ?? NaN;
      const time = h?.summary?.time ?? NaN;
      const star = h.favorite ? "★" : "☆";

      const li = document.createElement("li");
      li.innerHTML = `
        <div class="row" style="justify-content:space-between;">
          <div>
            <strong>${escapeHtml(h.name || "無題ルート")}</strong><br>
            <span class="small muted">距離 ${fmtMeters(dist)} / 時間 ${fmtSeconds(time)} / ${fmtDT(h.createdAt || Date.now())}</span>
          </div>
          <button class="btn btnSmall" type="button" data-action="hist-star" data-id="${escapeHtml(h.id)}" title="お気に入り">${star}</button>
        </div>
        <div class="row" style="margin-top:8px;">
          <button class="btn btnPrimary btnSmall" type="button" data-action="hist-show" data-id="${escapeHtml(h.id)}">再表示</button>
          <button class="btn btnSmall" type="button" data-action="hist-rename" data-id="${escapeHtml(h.id)}">名称変更</button>
          <button class="btn btnDanger btnSmall" type="button" data-action="hist-del" data-id="${escapeHtml(h.id)}">削除</button>
        </div>
      `;
      $historyList.appendChild(li);
    }
  }

  function showHistoryRoute(id) {
    const hist = loadHistory();
    const h = hist.find(x => String(x.id) === String(id));
    if (!h || !Array.isArray(h.coords) || h.coords.length === 0) return;

    resetStart(); resetEnd();
    setStart(L.latLng(h.start.lat, h.start.lng), h.start.label || "出発（履歴）");
    setEnd(L.latLng(h.end.lat, h.end.lng), h.end.label || "目的地（履歴）");

    clearPlannedRoute();
    plannedLineLayer = L.polyline(h.coords.map(p => [p.lat, p.lng]), { color: "#2b7", weight: 6, opacity: 0.85 }).addTo(map);

    const distance = h.summary?.distance ?? NaN;
    const time = h.summary?.time ?? NaN;
    $routeSummary.innerHTML =
      `計画（履歴）：<strong>${escapeHtml(h.name || "無題ルート")}</strong><br>` +
      `距離 <strong>${fmtMeters(distance)}</strong> / 時間 <strong>${fmtSeconds(time)}</strong> ` +
      `<span class="pill">${fmtDT(h.createdAt || Date.now())}</span>`;

    fitPlanAndActual();
    showToast("履歴ルートを表示しました");
  }

  function deleteHistoryRoute(id) {
    const hist = loadHistory().filter(x => String(x.id) !== String(id));
    saveHistory(hist);
    renderHistory();
  }
  function renameHistoryRoute(id) {
    const hist = loadHistory();
    const idx = hist.findIndex(x => String(x.id) === String(id));
    if (idx < 0) return;
    const cur = hist[idx];
    const name = prompt("ルート名を変更します", cur.name || "無題ルート");
    if (name == null) return;
    hist[idx] = { ...cur, name: name.trim() || "無題ルート" };
    saveHistory(hist);
    renderHistory();
  }
  function toggleHistoryFavorite(id) {
    const hist = loadHistory();
    const idx = hist.findIndex(x => String(x.id) === String(id));
    if (idx < 0) return;
    hist[idx] = { ...hist[idx], favorite: !hist[idx].favorite };
    saveHistory(hist);
    renderHistory();
  }
  function clearHistoryAll() {
    if (!confirm("ルート履歴を全削除します。よろしいですか？")) return;
    saveHistory([]);
    renderHistory();
  }

  // ===== Tracking =====
  function saveTrack() { saveJson(STORE_TRACK, trackPoints); }

  function computeTrackStats(points) {
    if (!points || points.length < 2) return { distance: 0, durationSec: 0, avgMps: 0 };
    let dist = 0;
    for (let i=1;i<points.length;i++) dist += haversineMeters(points[i-1], points[i]);
    const t0 = points[0].t;
    const t1 = points[points.length-1].t;
    const durationSec = Math.max(0, (t1 - t0) / 1000);
    const avgMps = durationSec > 0 ? dist / durationSec : 0;
    return { distance: dist, durationSec, avgMps };
  }
  function computeSegmentStats(points, segments) {
    if (!segments || segments.length === 0) return "";
    const lines = [];
    for (let i=0;i<segments.length;i++) {
      const seg = segments[i];
      const pts = points.slice(seg.startIndex, seg.endIndex + 1);
      if (pts.length < 2) continue;
      const st = computeTrackStats(pts);
      lines.push(`区間${i+1}: ${fmtMeters(st.distance)} / ${fmtSeconds(st.durationSec)} / ${fmtSpeed(st.avgMps)}`);
    }
    return lines.join(" / ");
  }
  function updateTrackSummary() {
    const pts = trackPoints;
    const st = computeTrackStats(pts);
    const note = pts.length >= 1 ? `開始: ${fmtDT(pts[0].t)} / 点数: ${pts.length}` : "未記録";
    const state = trackWatchId != null ? (trackIsPaused ? "（一時停止中）" : "（記録中）") : "";
    $trackSummary.innerHTML =
      `距離 <strong>${fmtMeters(st.distance)}</strong> / 時間 <strong>${fmtSeconds(st.durationSec)}</strong> / 平均速度 <strong>${fmtSpeed(st.avgMps)}</strong> ${state}<br>` +
      `<span class="small muted">${note}</span>`;
    const segText = computeSegmentStats(pts, segments);
    $segmentSummary.textContent = segText ? `区間別：${segText}` : "";
  }

  function startTracking() {
    if (!navigator.geolocation) { alert("この端末では位置情報が利用できません。"); return; }
    if (trackWatchId != null) { showToast("すでに記録中です"); return; }
    trackIsPaused = false;
    segments.push({ startIndex: trackPoints.length, endIndex: trackPoints.length });

    trackWatchId = navigator.geolocation.watchPosition(
      (pos) => {
        if (trackIsPaused) return;

        const lat = pos.coords.latitude;
        const lng = pos.coords.longitude;
        const acc = pos.coords.accuracy ?? 9999;
        const t = pos.timestamp ? Number(pos.timestamp) : Date.now();

        setCurrentPosition(lat, lng, acc);

        if (acc > trackSettings.maxAccM) return;

        const p = { lat, lng, t, acc };
        const last = trackPoints.length ? trackPoints[trackPoints.length - 1] : null;
        if (last) {
          const d = haversineMeters(last, p);
          if (d < trackSettings.minMoveM) return;
        }

        trackPoints.push(p);
        const seg = segments[segments.length - 1];
        if (seg) seg.endIndex = trackPoints.length - 1;

        saveTrack();
        redrawActual();
      },
      () => {
        showToast("位置情報の連続取得に失敗しました");
        stopTracking();
      },
      { enableHighAccuracy: true, maximumAge: 5000, timeout: 15000 }
    );

    ensureActualLayer();
    updateTrackSummary();
    showToast("記録を開始しました");
  }

  function pauseTracking() {
    if (trackWatchId == null) { showToast("記録中ではありません"); return; }
    trackIsPaused = true;
    updateTrackSummary();
    showToast("一時停止しました");
  }
  function resumeTracking() {
    if (trackWatchId == null) { showToast("記録開始してから再開してください"); return; }
    if (!trackIsPaused) { showToast("すでに記録中です"); return; }
    trackIsPaused = false;
    segments.push({ startIndex: trackPoints.length, endIndex: trackPoints.length });
    updateTrackSummary();
    showToast("再開しました");
  }
  function stopTracking() {
    if (trackWatchId != null) {
      navigator.geolocation.clearWatch(trackWatchId);
      trackWatchId = null;
    }
    trackIsPaused = false;
    updateTrackSummary();
    showToast("記録を停止しました");
  }
  function clearTrack() {
    if (!confirm("実績ルートを削除します。よろしいですか？")) return;
    stopTracking();
    trackPoints = [];
    segments = [];
    saveTrack();
    if (actualLineLayer) actualLineLayer.setLatLngs([]);
    updateTrackSummary();
    showToast("実績をクリアしました");
  }
  function exportGPX() {
    if (!trackPoints || trackPoints.length === 0) { showToast("実績ルートがありません"); return; }
    const name = `walk-${new Date().toISOString().slice(0,19).replace(/[:T]/g, "-")}`;

    const header =
`<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="tizu_sp_leaflet" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>${escapeXml(name)}</name>
    <time>${nowIso()}</time>
  </metadata>
  <trk>
    <name>${escapeXml(name)}</name>
    <trkseg>`;
    const pts = trackPoints.map(p => {
      const time = new Date(p.t).toISOString();
      return `      <trkpt lat="${p.lat}" lon="${p.lng}"><time>${time}</time></trkpt>`;
    }).join("\n");
    const footer =
`    </trkseg>
  </trk>
</gpx>`;
    const gpx = [header, pts, footer].join("\n");

    const blob = new Blob([gpx], { type: "application/gpx+xml" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${name}.gpx`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    showToast("GPXを書き出しました");
  }
  function escapeXml(s) {
    return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&apos;");
  }

  // ===== Overlay fit =====
  function fitPlanAndActual() {
    const layers = [];
    if (plannedLineLayer && plannedLineLayer.getLatLngs().length) layers.push(plannedLineLayer);
    if (actualLineLayer && actualLineLayer.getLatLngs().length) layers.push(actualLineLayer);
    if (layers.length === 0) { showToast("表示できる線がありません"); return; }
    const group = L.featureGroup(layers);
    map.fitBounds(group.getBounds(), { padding: [20, 20] });
  }

  // ===== Tabs UX =====
  function setTab(name) {
    uiState.tab = name; saveUI();
    for (const b of tabButtons) b.setAttribute("aria-selected", String(b.dataset.tab === name));
    for (const [k, el] of Object.entries(sections)) el.classList.toggle("isActive", k === name);
  }
  tabButtons.forEach(b => b.addEventListener("click", () => setTab(b.dataset.tab)));

  // ===== Misc actions =====
  function swapStartEnd() {
    if (!startLatLng && !endLatLng) return;
    const s = startLatLng, e = endLatLng;
    const sl = startLabel, el = endLabel;
    resetStart(); resetEnd();
    if (e) setStart(L.latLng(e.lat, e.lng), sl?.startsWith("出発：") ? sl.replace("出発：","出発：") : `出発：${el?.replace(/^目的地：/,"") || "地点"}`);
    if (s) setEnd(L.latLng(s.lat, s.lng), el?.startsWith("目的地：") ? el.replace("目的地：","目的地：") : `目的地：${sl?.replace(/^出発：/,"") || "地点"}`);
    showToast("出発と目的地を入れ替えました");
  }

  function clearAll() {
    clearPreview();
    resetStart(); resetEnd();
    clearPlannedRoute();
    $resStart.innerHTML = ""; $resEnd.innerHTML = "";
    $qStart.value = ""; $qEnd.value = "";
    showToast("出発・目的地・計画ルートをクリアしました");
  }

  function clearSearchHistory() {
    if (!confirm("検索履歴を削除します。よろしいですか？")) return;
    saveSearchHistory({ start: [], end: [] });
    renderSearchDatalist();
    showToast("検索履歴を削除しました");
  }

  // ===== Wire events =====
  $btnLocate.addEventListener("click", initMap);
  $btnFitBoth.addEventListener("click", fitPlanAndActual);
  $btnClearAll.addEventListener("click", clearAll);

  $btnSearchStart.addEventListener("click", doSearchStart);
  $btnSearchEnd.addEventListener("click", doSearchEnd);

  $qStart.addEventListener("keydown", (e) => { if (e.key === "Enter") { e.preventDefault(); doSearchStart(); } });
  $qEnd.addEventListener("keydown", (e) => { if (e.key === "Enter") { e.preventDefault(); doSearchEnd(); } });

  // optional live suggestion (only when typing; won't spam due to debounce + min length)
  $qStart.addEventListener("input", debouncedStart);
  $qEnd.addEventListener("input", debouncedEnd);

  $btnClearStart.addEventListener("click", () => { $qStart.value=""; $resStart.innerHTML=""; showToast("出発の検索をクリア"); });
  $btnClearEnd.addEventListener("click", () => { $qEnd.value=""; $resEnd.innerHTML=""; showToast("目的地の検索をクリア"); });

  $btnSetStartHere.addEventListener("click", () => {
    if (!currentPos) { showToast("先に現在地を取得してください"); return; }
    setStart(L.latLng(currentPos.lat, currentPos.lng), "出発：現在地");
    map.setView([currentPos.lat, currentPos.lng], 16);
    showToast("出発を現在地にしました");
  });
  $btnSetEndHere.addEventListener("click", () => {
    if (!currentPos) { showToast("先に現在地を取得してください"); return; }
    setEnd(L.latLng(currentPos.lat, currentPos.lng), "目的地：現在地");
    map.setView([currentPos.lat, currentPos.lng], 16);
    showToast("目的地を現在地にしました");
  });

  $btnSwap.addEventListener("click", swapStartEnd);

  $btnRoute.addEventListener("click", routeSearch);
  $btnRouteClear.addEventListener("click", () => { clearPlannedRoute(); showToast("計画ルートを消去しました"); });
  $btnStartReset.addEventListener("click", () => { resetStart(); showToast("出発をリセットしました"); });
  $btnEndReset.addEventListener("click", () => { resetEnd(); showToast("目的地をリセットしました"); });
  $btnNameSuggest.addEventListener("click", () => { suggestRouteName(); showToast("ルート名を自動入力しました"); });

  $btnHistoryRefresh.addEventListener("click", renderHistory);
  $btnHistoryFavOnly.addEventListener("click", () => {
    historyFavOnly = !historyFavOnly;
    $btnHistoryFavOnly.textContent = historyFavOnly ? "★のみ（ON）" : "★のみ";
    renderHistory();
  });
  $btnHistoryClear.addEventListener("click", clearHistoryAll);

  $btnTrackStart.addEventListener("click", startTracking);
  $btnTrackPause.addEventListener("click", pauseTracking);
  $btnTrackResume.addEventListener("click", resumeTracking);
  $btnTrackStop.addEventListener("click", stopTracking);
  $btnTrackClear.addEventListener("click", clearTrack);
  $btnGPX.addEventListener("click", exportGPX);

  $btnTrackSettingsSave.addEventListener("click", saveSettingsFromUI);
  $btnClearSearchHistory.addEventListener("click", clearSearchHistory);

  document.addEventListener("click", (e) => {
    const btn = e.target.closest("button[data-action]");
    if (!btn) return;
    const action = btn.dataset.action;
    const id = btn.dataset.id;
    if (action === "hist-show") { setTab("route"); showHistoryRoute(id); }
    if (action === "hist-del") deleteHistoryRoute(id);
    if (action === "hist-rename") renameHistoryRoute(id);
    if (action === "hist-star") toggleHistoryFavorite(id);
  });

  // keyboard shortcuts (avoid when typing in inputs)
  document.addEventListener("keydown", (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
    if (tag === "input" || tag === "textarea") return;

    if (e.key.toLowerCase() === "r") { routeSearch(); }
    if (e.key.toLowerCase() === "s") { resetStart(); showToast("出発リセット"); }
    if (e.key.toLowerCase() === "d") { resetEnd(); showToast("目的地リセット"); }
    if (e.key.toLowerCase() === "x") { swapStartEnd(); }
  });

  // ===== Init =====
  renderSearchDatalist();
  applySettingsToUI();
  redrawActual();
  initMap();

  // restore tab + start/end (if any)
  setTab(uiState.tab || "route");
  restoreStartEnd();
  updatePills();
  renderHistory();
})();

  // ==== スマホファーストUI（v1）：ナビ／ボトムシート／FAB ====
  function metersBetween(a, b){
    return map.distance(a, b); // Leafletの距離計算（WGS84）
  }

  function getStationCandidates(){
    const pts = [];
    enabledRoutes.forEach(route=>{
      const layer = stationLayers[route];
      if (!layer) return;
      layer.eachLayer(l=>{
        if (!l.getLatLng) return;
        const ll = l.getLatLng();
        const name = (l.getPopup && l.getPopup() && l.getPopup().getContent())
          ? String(l.getPopup().getContent()).replace(/<[^>]+>/g,'').trim()
          : (l.options && l.options.title) || "宿場";
        pts.push({ route, name, lat: ll.lat, lng: ll.lng });
      });
    });
    return pts;
  }

  function updateNavOverlay(lat, lng, accM){
    const sub = document.getElementById("navSub");
    if (sub) {
      const accTxt = (accM!=null && isFinite(accM)) ? ` / 精度±${Math.round(accM)}m` : "";
      sub.textContent = `現在地: ${lat.toFixed(5)}, ${lng.toFixed(5)}${accTxt}`;
    }

    const out = document.getElementById("navNext");
    if (!out) return;

    if (!enabledRoutes || enabledRoutes.size === 0){
      out.textContent = "次の宿場：—（街道未選択）";
      return;
    }

    const routes = Array.from(enabledRoutes);

    // データ欠落ガード（未ロード/不正データでクラッシュしない）
    const anyError = routes.some(r=>dataErrors[r]);
    const anyMissing = routes.some(r=>(!(stationIndex[r]&&stationIndex[r].length) || !routeCache[r]));
    if (anyError){
      out.textContent = "データ読み込み失敗…（更新/再読み込みしてください）";
      return;
    }
    if (anyMissing){
      out.textContent = "データ読み込み中...";
      return;
    }

    const hereLL = L.latLng(lat, lng);

    // 1街道ならそれを優先、複数なら「道なり距離が最短」の候補を選ぶ
    let best = null;

    for (const routeName of routes){
      const next = getNextStation(routeName, hereLL);
      if (!next) continue;
      const dRoute = calculateRouteDistance({lat, lng}, routeName, {lat: next.lat, lng: next.lng});
      const cand = { route: routeName, st: next, d: dRoute };
      if (!best || cand.d < best.d) best = cand;
    }

    if (!best){
      out.textContent = "次の宿場：—（宿場データ未表示）";
      return;
    }

    const km = best.d / 1000;
    const prefix = (routes.length > 1) ? `【${best.route}】` : "";
    out.textContent = `${prefix}次の宿場：${best.st.name} まで あと ${km.toFixed(km < 10 ? 2 : 1)}km`;

    // スタンプ判定（簡易）
    maybeStamp(best.route, best.st, hereLL, (accM!=null?Number(accM):null));
  }

  function setupSheetAndFab(){
    // ボトムシート（既存 row を活用）
    const row = document.querySelector(".panel > .row");
    if (row && !row.querySelector(".sheetHandle")){
      const h = document.createElement("div");
      h.className = "sheetHandle";
      h.title = "スワイプ/タップで開閉";
      row.prepend(h);

      // 初期は畳む（歩き中の視界優先）
      document.body.classList.add("sheet-collapsed");

      const toggle = ()=>document.body.classList.toggle("sheet-collapsed");
      h.addEventListener("click", toggle);
      const menu = document.getElementById("btnMenu");
      if (menu) menu.addEventListener("click", toggle);
    }

    // FAB：既存ボタンに委譲
    const locateBtn = document.getElementById("btn-locate");
    const fabLocate = document.getElementById("fabLocate");
    if (fabLocate && locateBtn) fabLocate.addEventListener("click", ()=>locateBtn.click());

    // 記録開始/停止（存在する場合のみ）
    const start = document.getElementById("btn-start-track");
    const stop  = document.getElementById("btn-stop-track");
    const fabRec = document.getElementById("fabRecord");
    if (fabRec){
      fabRec.addEventListener("click", ()=>{
        if (stop && !stop.disabled) return stop.click();
        if (start) return start.click();
      });
    }
  }

  // 初期化後にUIを組み立て
  window.addEventListener("load", setupSheetAndFab);

</script>
</body>
</html>
