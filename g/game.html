<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>飛べ！ブー之助 SAMURAI ROAD</title>
  <style>
    :root{ --pink:#ff69b4; --bg:#111; }
    body{
      margin:0; height:100vh; display:flex; justify-content:center; align-items:center;
      background:var(--bg); overflow:hidden; touch-action:none;
      font-family: system-ui, -apple-system, "Noto Sans JP", sans-serif; color:#fff;
    }
    .wrap{ position:relative; display:flex; flex-direction:column; align-items:center; gap:10px; }

    canvas{
      border:2px solid var(--pink);
      box-shadow:0 0 20px var(--pink);
      display:block;
      border-radius:12px;
    }

    /* ===== HUD（常に画面内）===== */
    .hud{
      position:absolute;
      top:10px;
      left:10px;
      right:10px;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
      pointer-events:none;
    }
    .hudBox{
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.15);
      border-radius:12px;
      padding:8px 10px;
      backdrop-filter: blur(6px);
      max-width:min(360px, 70vw);
    }
    .hudLine{ font-size:12px; opacity:.95; line-height:1.25; }
    .hudScore{ font-size:14px; font-weight:700; }
    .hudSmall{ font-size:11px; opacity:.85; }

    /* ===== ⚙️ボタン ===== */
    .menuBtn{
      position:absolute;
      top:10px;
      right:10px;
      z-index:20;
      pointer-events:auto;
      appearance:none;
      border:1px solid rgba(255,255,255,.25);
      background:rgba(255,255,255,.10);
      color:#fff;
      padding:8px 10px;
      border-radius:999px;
      cursor:pointer;
      font-size:13px;
    }
    .menuBtn:active{ transform: translateY(1px); }

    /* ===== ドロワー（下から出る）===== */
    .drawer{
      position:fixed;
      left:0; right:0; bottom:0;
      z-index:30;
      background:rgba(0,0,0,.78);
      backdrop-filter: blur(10px);
      border-top:1px solid rgba(255,105,180,.35);
      transform: translateY(110%);
      transition: transform .22s ease;
      padding:12px 12px 14px;
    }
    .drawer.open{ transform: translateY(0); }

    .drawerHeader{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      max-width:520px; margin:0 auto 10px;
    }
    .tabs{
      display:flex; gap:8px; flex-wrap:wrap;
    }
    .tab{
      appearance:none; cursor:pointer;
      border:1px solid rgba(255,255,255,.22);
      background:rgba(255,255,255,.08);
      color:#fff; padding:7px 10px;
      border-radius:999px; font-size:12px;
    }
    .tab.active{
      border-color: rgba(255,105,180,.7);
      box-shadow: 0 0 0 2px rgba(255,105,180,.18) inset;
    }
    .closeBtn{
      appearance:none; cursor:pointer;
      border:1px solid rgba(255,255,255,.25);
      background:rgba(255,255,255,.08);
      color:#fff; padding:7px 10px;
      border-radius:10px; font-size:12px;
    }

    .drawerBody{
      max-width:520px; margin:0 auto;
      display:none;
    }
    .drawerBody.active{ display:block; }

    .panel{
      width:100%;
      box-sizing:border-box;
      display:flex; flex-wrap:wrap; gap:8px 12px;
      align-items:center; justify-content:space-between;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.16);
      border-radius:12px;
      background:rgba(255,255,255,.06);
    }
    .row{ display:flex; align-items:center; gap:8px; flex:1 1 220px; min-width:220px; }
    label{ font-size:12px; opacity:.9; white-space:nowrap; }
    select, input[type="range"]{ width:100%; }
    .value{ font-size:12px; opacity:.9; min-width:52px; text-align:right; }

    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.25);
      background:rgba(255,255,255,.08);
      color:#fff;
      padding:8px 10px;
      border-radius:10px;
      cursor:pointer;
      font-size:13px;
      white-space:nowrap;
    }

    .hint{ font-size:12px; opacity:.85; margin-top:2px; text-align:center; }

    /* スマホでキャンバス優先（縦を食い過ぎない） */
    @media (max-height: 720px){
      .hint{ display:none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="gameCanvas"></canvas>

    <!-- HUD（常に見える） -->
    <div class="hud" aria-label="hud">
      <div class="hudBox">
        <div class="hudLine hudScore" id="hudScore">Score: 0</div>
        <div class="hudLine" id="hudAiMsg">AI: …</div>
        <div class="hudSmall" id="hudStats">癖: …</div>
      </div>
    </div>

    <!-- ⚙️ -->
    <button class="menuBtn" id="btnMenu" type="button">⚙️</button>

    <div class="hint">操作：長押しで上昇 / 離すと落下　｜　タップで開始・リトライ</div>
  </div>

  <!-- Drawer -->
  <div class="drawer" id="drawer">
    <div class="drawerHeader">
      <div class="tabs">
        <button class="tab active" data-pane="pane-level" type="button">レベル</button>
        <button class="tab" data-pane="pane-ai" type="button">AI表示</button>
      </div>
      <button class="closeBtn" id="btnClose" type="button">閉じる</button>
    </div>

    <div class="drawerBody active" id="pane-level">
      <div class="panel">
        <div class="row">
          <label for="preset">プリセット</label>
          <select id="preset">
            <option value="easy">EASY</option>
            <option value="normal" selected>NORMAL</option>
            <option value="hard">HARD</option>
            <option value="custom">CUSTOM</option>
          </select>
        </div>

        <div class="row">
          <label for="speedBase">速度</label>
          <input id="speedBase" type="range" min="2" max="6" step="0.1" value="3">
          <div class="value" id="speedBaseVal">3.0</div>
        </div>

        <div class="row">
          <label for="gapBase">間隔（上下の木）</label>
          <input id="gapBase" type="range" min="130" max="260" step="1" value="200">
          <div class="value" id="gapBaseVal">200</div>
        </div>

        <div class="row">
          <label for="spawnEvery">間隔（出現）</label>
          <input id="spawnEvery" type="range" min="70" max="170" step="1" value="115">
          <div class="value" id="spawnEveryVal">115</div>
        </div>

        <div class="row">
          <label for="accelEvery">加速（頻度）</label>
          <input id="accelEvery" type="range" min="0" max="900" step="10" value="650">
          <div class="value" id="accelEveryVal">650</div>
        </div>

        <div class="row" style="justify-content:flex-end; gap:10px;">
          <button class="btn" id="btnApply" type="button">適用（次から）</button>
          <button class="btn" id="btnRestart" type="button">即リトライ</button>
        </div>
      </div>
    </div>

    <div class="drawerBody" id="pane-ai">
      <div class="panel">
        <div class="row" style="flex:1 1 100%; min-width:100%;">
          <div style="font-size:12px; opacity:.9;">
            AIコメントと統計は <b>画面左上のHUD</b> に常時表示されます。<br>
            ここは今後「モード固定（癒し/普通/地獄）」などの設定を置く枠です。
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    const cssW = window.innerWidth > 480 ? 480 : Math.max(260, window.innerWidth - 20);
    const cssH = window.innerHeight > 640 ? 640 : Math.max(380, window.innerHeight - 20);
    const dpr = window.devicePixelRatio || 1;

    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return { w: cssW, h: cssH };
  }

  let { w: W, h: H } = resizeCanvas();
  let frames = 0, score = 0, gameState = 'START', gameSpeed = 3;

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  // HUD
  const hudScore = document.getElementById('hudScore');
  const hudAiMsg = document.getElementById('hudAiMsg');
  const hudStats = document.getElementById('hudStats');

  // Drawer UI
  const drawer = document.getElementById('drawer');
  const btnMenu = document.getElementById('btnMenu');
  const btnClose = document.getElementById('btnClose');

  btnMenu.addEventListener('click', ()=> drawer.classList.add('open'));
  btnClose.addEventListener('click', ()=> drawer.classList.remove('open'));
  drawer.addEventListener('click', (e)=>{
    if(e.target === drawer) drawer.classList.remove('open');
  });

  document.querySelectorAll('.tab').forEach(t=>{
    t.addEventListener('click', ()=>{
      document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
      t.classList.add('active');
      const pane = t.dataset.pane;
      document.querySelectorAll('.drawerBody').forEach(p=>p.classList.remove('active'));
      document.getElementById(pane).classList.add('active');
    });
  });

  // Difficulty
  const difficulty = { preset:'normal', speedBase:3.0, gapBase:200, spawnEvery:115, accelEvery:650 };
  let pendingDifficulty = { ...difficulty };
  const PRESETS = {
    easy:   { speedBase: 2.6, gapBase: 220, spawnEvery: 130, accelEvery: 720 },
    normal: { speedBase: 3.0, gapBase: 200, spawnEvery: 115, accelEvery: 650 },
    hard:   { speedBase: 3.6, gapBase: 170, spawnEvery:  98, accelEvery: 520 }
  };
  const applyDifficultyNow = ()=>Object.assign(difficulty, pendingDifficulty);

  const $ = (id)=>document.getElementById(id);
  const presetEl=$('preset'), speedBaseEl=$('speedBase'), gapBaseEl=$('gapBase'), spawnEveryEl=$('spawnEvery'), accelEveryEl=$('accelEvery');
  const speedBaseVal=$('speedBaseVal'), gapBaseVal=$('gapBaseVal'), spawnEveryVal=$('spawnEveryVal'), accelEveryVal=$('accelEveryVal');

  function syncVals(){
    speedBaseVal.textContent = Number(speedBaseEl.value).toFixed(1);
    gapBaseVal.textContent = String(gapBaseEl.value);
    spawnEveryVal.textContent = String(spawnEveryEl.value);
    accelEveryVal.textContent = String(accelEveryEl.value);
  }
  function setControlsFrom(obj){
    speedBaseEl.value=obj.speedBase; gapBaseEl.value=obj.gapBase; spawnEveryEl.value=obj.spawnEvery; accelEveryEl.value=obj.accelEvery;
    syncVals();
  }
  presetEl.addEventListener('change', ()=>{
    const p=presetEl.value;
    if(p!=='custom') setControlsFrom(PRESETS[p]);
  });
  [speedBaseEl,gapBaseEl,spawnEveryEl,accelEveryEl].forEach(el=>{
    el.addEventListener('input', ()=>{ presetEl.value='custom'; syncVals(); });
  });

  $('btnApply').addEventListener('click', ()=>{
    pendingDifficulty = {
      preset: presetEl.value,
      speedBase: Number(speedBaseEl.value),
      gapBase: Number(gapBaseEl.value),
      spawnEvery: Number(spawnEveryEl.value),
      accelEvery: Number(accelEveryEl.value)
    };
  });
  $('btnRestart').addEventListener('click', ()=>{
    pendingDifficulty = {
      preset: presetEl.value,
      speedBase: Number(speedBaseEl.value),
      gapBase: Number(gapBaseEl.value),
      spawnEvery: Number(spawnEveryEl.value),
      accelEvery: Number(accelEveryEl.value)
    };
    resetGame();
    drawer.classList.remove('open');
  });

  presetEl.value='normal';
  setControlsFrom(PRESETS.normal);
  pendingDifficulty = { preset:'normal', ...PRESETS.normal };
  applyDifficultyNow();
  gameSpeed = difficulty.speedBase;

  // Images
  const imgBody = new Image(); imgBody.src = './images/buunosuke_body.png';
  const imgProp = new Image(); imgProp.src = './images/buunosuke_propeller.png';
  let imagesReady=false, loaded=0;
  [imgBody,imgProp].forEach(im=>im.onload=()=>{ if(++loaded===2) imagesReady=true; });

  // AI
  const ai = {
    mode:'normal', biasY:0, gapBoost:0, speedBoost:0,
    passStreak:0, failStreak:0, lastDeath:null, msg:"最初は様子見。"
  };
  const stats = {
    emaY:0.5, emaPress:0.0,
    deaths:{TOP:0,BOTTOM:0,FLOOR:0},
    lastPassFrame:0
  };
  let gameOverLines=["","",""];

  function setAiMode(m){
    if(ai.mode===m) return;
    ai.mode=m;
    ai.msg = (m==='soothe')?"癒しモード：少し優しくする。":(m==='hell'?"地獄モード：容赦しない。":"普通モード：普段通り。");
  }
  function maybeUpdateAiMode(){
    if(ai.failStreak>=3) setAiMode('soothe');
    else if(ai.passStreak>=6) setAiMode('hell');
    else setAiMode('normal');
  }
  function modeDeltas(){
    if(ai.mode==='soothe') return { gap:+22, spd:-0.25, spawn:+10 };
    if(ai.mode==='hell') return { gap:-18, spd:+0.35, spawn:-10 };
    return { gap:0, spd:0, spawn:0 };
  }
  function buildGameOverAnalysis(){
    const top=stats.deaths.TOP, bot=stats.deaths.BOTTOM, flo=stats.deaths.FLOOR;
    let main="原因：";
    main += (ai.lastDeath==='TOP')?"上に当たりやすい":(ai.lastDeath==='BOTTOM'?"下に当たりやすい":"落ちやすい");
    let habit="癖：";
    habit += (stats.emaY<0.35)?"高めで粘る":(stats.emaY>0.65?"低めに沈む":"中央維持");
    habit += `／押下率≈${Math.round(stats.emaPress*100)}%`;
    let tip="次：";
    tip += (ai.lastDeath==='TOP')?"“下側”を通す。長押しを短く。":
           (ai.lastDeath==='BOTTOM')?"“上側”に逃がす。落ち始める前に1回。":
           "落ちる前に小刻み。長押しで救わない。";
    const sum = `内訳：上${top}/下${bot}/落${flo}`;
    gameOverLines=[main, habit, tip+" "+sum];
  }

  // +1 popup
  const popups=[];
  function addPopup(text,x,y){ popups.push({text,x,y,life:40}); }
  function drawPopups(){
    for(let i=0;i<popups.length;i++){
      const p=popups[i]; p.life--; p.y-=0.6;
      ctx.save();
      ctx.globalAlpha=clamp(p.life/40,0,1);
      ctx.fillStyle='#fff'; ctx.font='14px Arial';
      ctx.fillText(p.text,p.x,p.y);
      ctx.restore();
      if(p.life<=0){ popups.splice(i,1); i--; }
    }
  }

  // Player
  const buunosuke = {
    x:60,y:H/2,width:56,height:56,velocity:0,
    gravity:0.28, thrust:-0.35, maxUp:-4.6, maxDown:6.5,
    isFlying:false,
    propOffsetX:28, propOffsetY:8, propSize:20,

    update(){
      if(gameState!=='PLAYING') return;

      this.velocity += this.isFlying ? this.thrust : this.gravity;
      this.velocity = clamp(this.velocity, this.maxUp, this.maxDown);
      this.y += this.velocity;

      if(this.y<0){ this.y=0; this.velocity=0; }
      if(this.y+this.height>H){
        this.y=H-this.height;
        ai.lastDeath='FLOOR'; stats.deaths.FLOOR++;
        gameState='GAMEOVER'; buildGameOverAnalysis();
      }
    },
    draw(){
      if(!imagesReady) return;
      const tilt = clamp(this.velocity*0.02, -0.10, 0.14);
      const spin = 0.25 + Math.abs(this.velocity)*0.12;
      const px = this.x + this.propOffsetX;
      const py = this.y + this.propOffsetY;

      ctx.save();
      ctx.translate(this.x+this.width/2, this.y+this.height/2);
      ctx.rotate(tilt);
      ctx.translate(-(this.x+this.width/2), -(this.y+this.height/2));

      ctx.drawImage(imgBody, this.x, this.y, this.width, this.height);

      ctx.save();
      ctx.translate(px,py);
      ctx.rotate(frames*spin);
      ctx.drawImage(imgProp, -this.propSize/2, -this.propSize/2, this.propSize, this.propSize);
      ctx.restore();

      ctx.restore();
    }
  };

  // Obstacles
  const pipes=[];
  function handleObstacles(){
    if(gameState!=='PLAYING') return;

    maybeUpdateAiMode();
    const md = modeDeltas();

    const baseGap = difficulty.gapBase + md.gap;
    const gapHeight = clamp((baseGap + ai.gapBoost) - (gameSpeed - difficulty.speedBase)*6, 120, 300);
    const spawnEvery = clamp(difficulty.spawnEvery + md.spawn, 70, 180);
    const effectiveSpeed = clamp(gameSpeed + ai.speedBoost + md.spd, 2.0, 8.0);

    if(frames % spawnEvery === 0){
      const margin=34;
      let gapTop = Math.random()*(H-gapHeight-margin*2)+margin;
      gapTop = clamp(gapTop + ai.biasY*0.4, margin, H-gapHeight-margin);
      pipes.push({x:W,w:54,gapTop,gapHeight,passed:false});
    }

    for(let i=0;i<pipes.length;i++){
      const p=pipes[i];
      p.x -= effectiveSpeed;

      ctx.fillStyle='#551a1a';
      ctx.fillRect(p.x,0,p.w,p.gapTop);
      ctx.fillRect(p.x,p.gapTop+p.gapHeight,p.w,H-(p.gapTop+p.gapHeight));

      const overlapX = (buunosuke.x < p.x+p.w) && (buunosuke.x+buunosuke.width > p.x);
      const hitTop = overlapX && (buunosuke.y < p.gapTop);
      const hitBottom = overlapX && (buunosuke.y+buunosuke.height > p.gapTop+p.gapHeight);
      if(hitTop || hitBottom){
        ai.lastDeath = hitTop ? 'TOP' : 'BOTTOM';
        stats.deaths[ai.lastDeath]++;
        gameState='GAMEOVER';
        buildGameOverAnalysis();
      }

      // score（中心越え）
      const buuCenterX = buunosuke.x + buunosuke.width/2;
      const pipeCenterX = p.x + p.w/2;
      if(!p.passed && buuCenterX > pipeCenterX){
        p.passed=true;
        score++;
        stats.lastPassFrame=frames;

        ai.passStreak++; ai.failStreak=0;
        ai.gapBoost = clamp(ai.gapBoost - 1.5, 0, 45);
        ai.speedBoost = clamp(ai.speedBoost + 0.03, -0.6, 0);

        addPopup("+1", buunosuke.x+20, buunosuke.y-6);
      }

      if(p.x+p.w<0){ pipes.splice(i,1); i--; }
    }
  }

  // Background
  function drawBackground(){
    const g=ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,"#0a0a2a"); g.addColorStop(1,"#2a0a1a");
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#ffb7c5';
    for(let i=0;i<20;i++){
      const x=(frames*2 + i*50)%W;
      const y=(Math.sin(frames/50+i)*H/2)+H/2;
      ctx.beginPath(); ctx.arc(x,y,(i%3)+2,0,Math.PI*2); ctx.fill();
    }
  }

  function updateHud(){
    // stats
    const cy = (buunosuke.y + buunosuke.height/2) / Math.max(1,H);
    stats.emaY = lerp(stats.emaY, clamp(cy,0,1), 0.03);
    stats.emaPress = lerp(stats.emaPress, buunosuke.isFlying ? 1 : 0, 0.05);

    const yLabel = stats.emaY < 0.35 ? "高め" : (stats.emaY > 0.65 ? "低め" : "中央");
    const pressPct = Math.round(stats.emaPress*100);

    hudScore.textContent = "Score: " + score;
    hudAiMsg.textContent = "AI: " + ai.msg;
    hudStats.textContent = `癖：高度=${yLabel} / 押下率≈${pressPct}% / 死因 上:${stats.deaths.TOP} 下:${stats.deaths.BOTTOM} 落:${stats.deaths.FLOOR}`;
  }

  function drawUI(){
    if(gameState==='START'){
      ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.textAlign='center';
      ctx.font='24px Arial'; ctx.fillText('SAMURAI ROAD', W/2, H/2-20);
      ctx.font='16px Arial'; ctx.fillText('タップ/クリックでスタート', W/2, H/2+30);
      ctx.textAlign='left';
    }else if(gameState==='GAMEOVER'){
      ctx.fillStyle='rgba(0,0,0,0.68)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='red'; ctx.textAlign='center';
      ctx.font='30px Arial'; ctx.fillText('GAME OVER', W/2, H/2-30);

      ctx.fillStyle='rgba(255,255,255,0.95)';
      ctx.font='14px Arial';
      ctx.fillText(gameOverLines[0], W/2, H/2+5);
      ctx.fillText(gameOverLines[1], W/2, H/2+28);
      ctx.fillText(gameOverLines[2], W/2, H/2+51);

      ctx.fillStyle='#fff'; ctx.font='16px Arial';
      ctx.fillText('タップ/クリックでリトライ', W/2, H/2+86);
      ctx.textAlign='left';
    }
  }

  function applyAiAfterDeath(){
    if(!ai.lastDeath) return;

    ai.failStreak++; ai.passStreak=0;
    ai.gapBoost = clamp(ai.gapBoost + 8 + ai.failStreak*2, 0, 45);
    ai.speedBoost = clamp(ai.speedBoost - 0.08 - ai.failStreak*0.01, -0.6, 0);

    if(ai.lastDeath==='TOP') ai.biasY = clamp(ai.biasY + 8, -80, 80);
    if(ai.lastDeath==='BOTTOM') ai.biasY = clamp(ai.biasY - 8, -80, 80);
    if(ai.lastDeath==='FLOOR') ai.biasY = clamp(ai.biasY - 12, -80, 80);

    ai.msg = (ai.lastDeath==='TOP')?"上に当たりがち。ギャップを少し下へ。":
             (ai.lastDeath==='BOTTOM')?"下に当たりがち。ギャップを少し上へ。":
             "落ちやすい。少し優しくする。";

    ai.lastDeath=null;
  }

  function resetGame(){
    applyDifficultyNow();
    ({w:W,h:H}=resizeCanvas());
    applyAiAfterDeath();

    buunosuke.y=H/2; buunosuke.velocity=0;
    pipes.length=0; popups.length=0;
    score=0; frames=0;
    gameSpeed=difficulty.speedBase;
    gameState='PLAYING';
    updateHud();
  }

  // Loop
  function loop(){
    ctx.clearRect(0,0,W,H);
    drawBackground();

    if(gameState==='PLAYING'){
      updateHud();
      frames++;
      if(difficulty.accelEvery>0 && frames % difficulty.accelEvery === 0) gameSpeed += 0.5;
    }

    buunosuke.update();
    handleObstacles();
    buunosuke.draw();
    drawPopups();
    drawUI();

    requestAnimationFrame(loop);
  }

  // Input
  function pressStartOrFly(){
    if(gameState==='PLAYING') buunosuke.isFlying=true;
    else resetGame();
  }
  function releaseFly(){ buunosuke.isFlying=false; }

  canvas.addEventListener('mousedown', pressStartOrFly);
  canvas.addEventListener('mouseup', releaseFly);
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); pressStartOrFly(); }, {passive:false});
  canvas.addEventListener('touchend', (e)=>{ e.preventDefault(); releaseFly(); }, {passive:false});
  canvas.addEventListener('touchcancel', (e)=>{ e.preventDefault(); releaseFly(); }, {passive:false});

  window.addEventListener('resize', ()=>{
    ({w:W,h:H}=resizeCanvas());
    if(gameState!=='PLAYING') buunosuke.y=H/2;
  });

  // 初期HUD
  updateHud();
  loop();
</script>
</body>
</html>
