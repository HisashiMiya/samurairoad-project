<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>é£›ã¹ï¼ãƒ–ãƒ¼ä¹‹åŠ© SAMURAI ROAD</title>
  <style>
    :root{ --pink:#ff69b4; --bg:#111; }
    body{
      margin:0; height:100vh; display:flex; justify-content:center; align-items:center;
      background:var(--bg); overflow:hidden; touch-action:none;
      font-family: system-ui, -apple-system, "Noto Sans JP", sans-serif; color:#fff;
    }
    .wrap{ position:relative; display:flex; flex-direction:column; align-items:center; gap:10px; }

    canvas{
      border:2px solid var(--pink);
      box-shadow:0 0 20px var(--pink);
      display:block;
      border-radius:12px;
    }

    /* HUD */
    .hud{
      position:absolute; top:10px; left:10px; right:10px;
      display:flex; justify-content:space-between; align-items:flex-start; gap:10px;
      pointer-events:none;
    }
    .hudBox{
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.15);
      border-radius:12px;
      padding:8px 10px;
      backdrop-filter: blur(6px);
      max-width:min(420px, 78vw);
    }
    .hudLine{ font-size:12px; opacity:.95; line-height:1.25; }
    .hudScore{ font-size:14px; font-weight:700; }
    .hudSmall{ font-size:11px; opacity:.85; }
    #hudStats{ display:none; }

    /* âš™ï¸ */
    .menuBtn{
      position:absolute; top:10px; right:10px;
      z-index:20; pointer-events:auto;
      appearance:none;
      border:1px solid rgba(255,255,255,.25);
      background:rgba(255,255,255,.10);
      color:#fff;
      padding:8px 10px;
      border-radius:999px;
      cursor:pointer;
      font-size:13px;
    }
    .menuBtn:active{ transform: translateY(1px); }

    /* Drawer */
    .drawer{
      position:fixed; left:0; right:0; bottom:0; z-index:30;
      background:rgba(0,0,0,.78);
      backdrop-filter: blur(10px);
      border-top:1px solid rgba(255,105,180,.35);
      transform: translateY(110%);
      transition: transform .22s ease;
      padding:12px 12px 14px;
    }
    .drawer.open{ transform: translateY(0); }

    .drawerHeader{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      max-width:560px; margin:0 auto 10px;
    }
    .tabs{ display:flex; gap:8px; flex-wrap:wrap; }
    .tab{
      appearance:none; cursor:pointer;
      border:1px solid rgba(255,255,255,.22);
      background:rgba(255,255,255,.08);
      color:#fff; padding:7px 10px;
      border-radius:999px; font-size:12px;
    }
    .tab.active{
      border-color: rgba(255,105,180,.7);
      box-shadow: 0 0 0 2px rgba(255,105,180,.18) inset;
    }
    .closeBtn{
      appearance:none; cursor:pointer;
      border:1px solid rgba(255,255,255,.25);
      background:rgba(255,255,255,.08);
      color:#fff; padding:7px 10px;
      border-radius:10px; font-size:12px;
    }

    .drawerBody{ max-width:560px; margin:0 auto; display:none; }
    .drawerBody.active{ display:block; }

    .panel{
      width:100%;
      box-sizing:border-box;
      display:flex; flex-wrap:wrap; gap:8px 12px;
      align-items:center; justify-content:space-between;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.16);
      border-radius:12px;
      background:rgba(255,255,255,.06);
    }
    .row{ display:flex; align-items:center; gap:8px; flex:1 1 240px; min-width:240px; }
    label{ font-size:12px; opacity:.9; white-space:nowrap; }
    select, input[type="range"]{ width:100%; }
    .value{ font-size:12px; opacity:.9; min-width:52px; text-align:right; }

    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.25);
      background:rgba(255,255,255,.08);
      color:#fff;
      padding:8px 10px;
      border-radius:10px;
      cursor:pointer;
      font-size:13px;
      white-space:nowrap;
    }
    .btnPrimary{
      border-color: rgba(255,105,180,.55);
      box-shadow: 0 0 0 2px rgba(255,105,180,.12) inset;
    }

    .hint{ font-size:12px; opacity:.85; margin-top:2px; text-align:center; }

    .howto{ font-size:13px; line-height:1.6; opacity:.95; }
    .howto h3{ margin:6px 0 6px; font-size:14px; }
    .howto ul{ margin:6px 0 6px 18px; padding:0; }
    .note{
      font-size:12px; opacity:.85;
      border-left:3px solid rgba(255,105,180,.6);
      padding-left:10px;
      margin-top:8px;
    }
/* SamuraiRoad footer : game page safe mode */
#sr-footer-mount {
  display: none;      /* ç”»é¢ã«ã¯å‡ºã•ãªã„ */
}

    @media (max-height: 720px){
      .hint{ display:none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="gameCanvas"></canvas>

    <div class="hud" aria-label="hud">
      <div class="hudBox">
        <div class="hudLine hudScore" id="hudScore">Score: 0</div>
        <div class="hudLine" id="hudAiMsg">AI: â€¦</div>
        <div class="hudSmall" id="hudStats">â€¦</div>
      </div>
    </div>

    <button class="menuBtn" id="btnMenu" type="button">âš™ï¸</button>
    <div class="hint" id="hintLine">æ“ä½œï¼šé•·æŠ¼ã—ã§ä¸Šæ˜‡ / é›¢ã™ã¨è½ä¸‹ã€€ï½œã€€ã‚¿ãƒƒãƒ—ã§é–‹å§‹ãƒ»ãƒªãƒˆãƒ©ã‚¤</div>
  </div>

  <div class="drawer" id="drawer">
    <div class="drawerHeader">
      <div class="tabs">
        <button class="tab active" data-pane="pane-level" type="button" id="tabLevel">ãƒ¬ãƒ™ãƒ«</button>
        <button class="tab" data-pane="pane-sound" type="button" id="tabSound">éŸ³</button>
        <button class="tab" data-pane="pane-dev" type="button" id="tabDev">é–‹ç™ºè€…</button>
        <button class="tab" data-pane="pane-howto" type="button" id="tabHowto">ä½¿ã„æ–¹</button>
        <button class="tab" data-pane="pane-feedback" type="button" id="tabFeedback">ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯</button>
        <button class="tab" data-pane="pane-lang" type="button" id="tabLang">è¨€èª</button>
      </div>
      <button class="closeBtn" id="btnClose" type="button">é–‰ã˜ã‚‹</button>
    </div>

    <div class="drawerBody active" id="pane-level">
      <div class="panel">
        <div class="row">
          <label for="flightMode" id="lblMode">é£›è¡Œã‚¿ã‚¤ãƒ—</label>
          <select id="flightMode">
            <option value="fly">FLYï¼ˆæ™®é€šï¼‰</option>
            <option value="ground">GROUNDï¼ˆåœ°ã‚’é€™ã†ï¼‰</option>
          </select>
        </div>

        <div class="row">
          <label for="preset" id="lblPreset">ãƒ—ãƒªã‚»ãƒƒãƒˆ</label>
          <select id="preset">
            <option value="easy">EASY</option>
            <option value="normal" selected>NORMAL</option>
            <option value="hard">HARD</option>
            <option value="custom">CUSTOM</option>
          </select>
        </div>

        <div class="row">
          <label for="speedBase" id="lblSpeed">é€Ÿåº¦</label>
          <input id="speedBase" type="range" min="2" max="6" step="0.1" value="3">
          <div class="value" id="speedBaseVal">3.0</div>
        </div>

        <div class="row">
          <label for="gapBase" id="lblGap">é–“éš”ï¼ˆä¸Šä¸‹ã®æœ¨ï¼‰</label>
          <input id="gapBase" type="range" min="130" max="260" step="1" value="200">
          <div class="value" id="gapBaseVal">200</div>
        </div>

        <div class="row">
          <label for="spawnEvery" id="lblSpawn">é–“éš”ï¼ˆå‡ºç¾ï¼‰</label>
          <input id="spawnEvery" type="range" min="70" max="170" step="1" value="115">
          <div class="value" id="spawnEveryVal">115</div>
        </div>

        <div class="row">
          <label for="accelEvery" id="lblAccel">åŠ é€Ÿï¼ˆé »åº¦ï¼‰</label>
          <input id="accelEvery" type="range" min="0" max="900" step="10" value="650">
          <div class="value" id="accelEveryVal">650</div>
        </div>

        <div class="row" style="justify-content:flex-end; gap:10px;">
          <button class="btn" id="btnApply" type="button">é©ç”¨ï¼ˆæ¬¡ã‹ã‚‰ï¼‰</button>
          <button class="btn" id="btnRestart" type="button">å³ãƒªãƒˆãƒ©ã‚¤</button>
        </div>
      </div>
    </div>

    <div class="drawerBody" id="pane-sound">
      <div class="panel">
                <div class="row">
                  <label for="soundToggle" id="lblSound">éŸ³æ¥½</label>
                  <select id="soundToggle">
                    <option value="on">ON</option>
                    <option value="off">OFF</option>
                  </select>
                </div>

                <div class="row">
                  <label for="soundVol" id="lblVol">éŸ³é‡</label>
                  <input id="soundVol" type="range" min="0" max="1" step="0.01" value="0.35">
                  <div class="value" id="soundVolVal">0.35</div>
                </div>
        <div class="row">
          <div class="small" style="opacity:.9; line-height:1.4;">
            â€» ãƒ–ãƒ©ã‚¦ã‚¶ä»•æ§˜ã§ã€æœ€åˆã®1å›ã¯ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒ—å¾Œã«éŸ³ãŒæœ‰åŠ¹ã«ãªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
          </div>
        </div>
      </div>
    </div>

    <div class="drawerBody" id="pane-dev">
      <div class="panel">
        <div class="row">
          <label for="debugToggle" id="lblDebug">Debugè¡¨ç¤º</label>
          <select id="debugToggle">
            <option value="off" selected>OFFï¼ˆé€šå¸¸ï¼‰</option>
            <option value="on">ONï¼ˆé–‹ç™ºè€…ï¼‰</option>
          </select>
        </div>
        <div class="row">
          <div class="small" style="opacity:.9; line-height:1.4;">
            â€» ONã«ã™ã‚‹ã¨ã€ç”»é¢å³ä¸Šã«ãƒ‡ãƒãƒƒã‚°æƒ…å ±ï¼ˆæŠ¼ä¸‹ç‡ãƒ»ç”»åƒ/éŸ³ã®çŠ¶æ…‹ãªã©ï¼‰ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚
          </div>
        </div>
      </div>
    </div>


    <div class="drawerBody" id="pane-howto">
      <div class="panel">
        <div class="howto" id="howtoBox"></div>
      </div>
    </div>

    <div class="drawerBody" id="pane-feedback">
      <div class="panel">
        <div class="row" style="flex:1 1 100%; min-width:100%;">
          <div class="howto" id="feedbackText"></div>
        </div>
        <div class="row" style="justify-content:flex-end; gap:10px; flex:1 1 100%; min-width:100%;">
          <button class="btn btnPrimary" id="btnBug" type="button">ğŸ› ãƒã‚°å ±å‘Š</button>
          <button class="btn btnPrimary" id="btnReq" type="button">âœ¨ è¦æœ›</button>
        </div>
        <div class="row" style="flex:1 1 100%; min-width:100%;">
          <div class="note" id="fbNote">â€» GitHubã®Issueãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»é¢ã«ç§»å‹•ã—ã¾ã™ï¼ˆæŠ•ç¨¿ã«ã¯ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™ï¼‰</div>
        </div>
      </div>
    </div>

    <div class="drawerBody" id="pane-lang">
      <div class="panel">
        <div class="row">
          <label for="langSel" id="lblLang">è¨€èª</label>
          <select id="langSel">
            <option value="ja">æ—¥æœ¬èª</option>
            <option value="en">English</option>
          </select>
        </div>
        <div class="row" style="flex:1 1 100%; min-width:100%;">
          <div class="note" id="langNote">è¨€èªã¯ç«¯æœ«ã«ä¿å­˜ã•ã‚Œã¾ã™ï¼ˆæ¬¡å›ã‚‚ç¶­æŒï¼‰ã€‚</div>
        </div>
      </div>
    </div>
  </div>

<!-- Footer mount -->
<div data-include="../../includes/footer.html" aria-label="Footer"></div>
<!-- å…±é€šJSï¼ˆdeferå¿…é ˆï¼‰ -->
<script src="../../assets/js/sr-common.js" defer></script>

<script>
  const ISSUE_URL = "https://github.com/HisashiMiya/samurairoad-project/issues/new/choose";

  // =========================
  // i18n
  // =========================
  const I18N = {
    ja: {
      hint: "æ“ä½œï¼šé•·æŠ¼ã—ã§ä¸Šæ˜‡ / é›¢ã™ã¨è½ä¸‹ã€€ï½œã€€ã‚¿ãƒƒãƒ—ã§é–‹å§‹ãƒ»ãƒªãƒˆãƒ©ã‚¤",
      tabLevel: "ãƒ¬ãƒ™ãƒ«", tabHowto: "ä½¿ã„æ–¹", tabFeedback: "ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯", tabLang: "è¨€èª",
      close: "é–‰ã˜ã‚‹",
      mode: "é£›è¡Œã‚¿ã‚¤ãƒ—",
      modeFly: "FLYï¼ˆæ™®é€šï¼‰",
      modeGround: "GROUNDï¼ˆåœ°ã‚’é€™ã†ï¼‰",
      preset: "ãƒ—ãƒªã‚»ãƒƒãƒˆ", speed: "é€Ÿåº¦", gap: "é–“éš”ï¼ˆä¸Šä¸‹ã®æœ¨ï¼‰", spawn: "é–“éš”ï¼ˆå‡ºç¾ï¼‰", accel: "åŠ é€Ÿï¼ˆé »åº¦ï¼‰",
      sound: "éŸ³æ¥½", soundOn: "ON", soundOff: "OFF", vol: "éŸ³é‡",
      apply: "é©ç”¨ï¼ˆæ¬¡ã‹ã‚‰ï¼‰", restart: "å³ãƒªãƒˆãƒ©ã‚¤",
      lang: "è¨€èª",
      langNote: "è¨€èªã¯ç«¯æœ«ã«ä¿å­˜ã•ã‚Œã¾ã™ï¼ˆæ¬¡å›ã‚‚ç¶­æŒï¼‰ã€‚",
      startTitle: "SAMURAI ROAD",
      startSub: "ã‚¿ãƒƒãƒ—/ã‚¯ãƒªãƒƒã‚¯ã§ã‚¹ã‚¿ãƒ¼ãƒˆ",
      gameOver: "GAME OVER",
      retry: "ã‚¿ãƒƒãƒ—/ã‚¯ãƒªãƒƒã‚¯ã§ãƒªãƒˆãƒ©ã‚¤",
      score: "Score",
      ai: "AI",
      next: "æ¬¡ã®ä¸€æ‰‹",
      feedbackText: `
        <h3>ãƒã‚°å ±å‘Šãƒ»è¦æœ›</h3>
        <ul>
          <li>ãƒ—ãƒ¬ã‚¤ä¸­ã«æ°—ã¥ã„ãŸé•å’Œæ„Ÿã‚’ã€ãã®ã¾ã¾é€ã‚Œã¾ã™</li>
          <li>GitHub Issues ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆé¸æŠç”»é¢ã«ç§»å‹•ã—ã¾ã™</li>
        </ul>
        <div class="note">
          ä¾‹ï¼šã‚¹ãƒãƒ›ã§è¦‹åˆ‡ã‚Œã‚‹ / ã‚¹ã‚³ã‚¢ãŒå¢—ãˆãªã„ / æ“ä½œãŒé‡ã„ / ç”»åƒãŒå‡ºãªã„ ãªã©
        </div>
      `,
      bug: "ğŸ› ãƒã‚°å ±å‘Š",
      req: "âœ¨ è¦æœ›",
      fbNote: "â€» GitHubã®Issueãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»é¢ã«ç§»å‹•ã—ã¾ã™ï¼ˆæŠ•ç¨¿ã«ã¯ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™ï¼‰",
      howtoHtml: `
        <h3>åŸºæœ¬æ“ä½œ</h3>
        <ul>
          <li><b>é•·æŠ¼ã—</b>ï¼šä¸Šæ˜‡ï¼ˆæŠ¼ã—ã¦ã„ã‚‹é–“ã€å°‘ã—ãšã¤ä¸ŠãŒã‚Šã¾ã™ï¼‰</li>
          <li><b>é›¢ã™</b>ï¼šè½ä¸‹ï¼ˆé‡åŠ›ã§ä¸‹ãŒã‚Šã¾ã™ï¼‰</li>
          <li><b>ã‚¿ãƒƒãƒ—</b>ï¼šã‚¹ã‚¿ãƒ¼ãƒˆ / ãƒªãƒˆãƒ©ã‚¤</li>
        </ul>

        <h3>ãƒ¢ãƒ¼ãƒ‰</h3>
        <ul>
          <li><b>FLY</b>ï¼šæ™®é€šã«é£›ã¹ã‚‹ï¼ˆãƒ•ãƒ©ãƒƒãƒ”ãƒ¼ç³»ï¼‰</li>
          <li><b>GROUND</b>ï¼šåŸºæœ¬ã¯åœ°ã‚’é€™ã†ã€‚æºœã‚ãŒè²¯ã¾ã£ãŸã¨ãã ã‘çŸ­ãæµ®ã</li>
        </ul>

        <h3>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ˆåº•ï¼‰</h3>
        <ul>
          <li>ä¸Šä¸‹ã®æœ¨ã«å½“ãŸã‚‹</li>
          <li><b>ç”»é¢ã®ä¸‹ï¼ˆåºŠï¼‰ã«è§¦ã‚Œã‚‹</b> â†’ å³ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</li>
        </ul>

        <h3>ã‚¹ã‚³ã‚¢</h3>
        <ul>
          <li>ä¸Šä¸‹ã®æœ¨ <b>1ã‚»ãƒƒãƒˆ</b> ã‚’ <b>ã¶ã¤ã‹ã‚‰ãšã«é€šé</b> ã™ã‚‹ã¨ <b>+1</b></li>
          <li>ã€Œæœ¨ã®çœŸã‚“ä¸­ã‚’è¶ŠãˆãŸã€ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§åŠ ç‚¹ã—ã¾ã™</li>
        </ul>

        <div class="note">
          â€»ã‚¹ãƒãƒ›ã®ã€Œã‚¿ãƒƒãƒ—ã®å¼·ã•ï¼ˆåœ§åŠ›ï¼‰ã€ã§ã¯ä¸Šæ˜‡é‡ã¯å¤‰ã‚ã‚Šã¾ã›ã‚“ã€‚<br>
          ä¸Šæ˜‡ã¯ã€ŒæŠ¼ã—ã¦ã„ã‚‹æ™‚é–“ã€ã§æ±ºã¾ã‚Šã¾ã™ã€‚
        </div>
      `
    },
    en: {
      hint: "Controls: Hold to rise / Release to fall | Tap to start & retry",
      tabLevel: "Level", tabHowto: "How to play", tabFeedback: "Feedback", tabLang: "Language",
      close: "Close",
      mode: "Flight type",
      modeFly: "FLY (normal)",
      modeGround: "GROUND (crawl)",
      preset: "Preset", speed: "Speed", gap: "Gap (top/bottom)", spawn: "Spawn interval", accel: "Acceleration",
      sound: "Music", soundOn: "ON", soundOff: "OFF", vol: "Volume",
      apply: "Apply (next run)", restart: "Restart now",
      lang: "Language",
      langNote: "Language is saved on this device.",
      startTitle: "SAMURAI ROAD",
      startSub: "Tap/click to start",
      gameOver: "GAME OVER",
      retry: "Tap/click to retry",
      score: "Score",
      ai: "AI",
      next: "Next move",
      feedbackText: `
        <h3>Bug reports & requests</h3>
        <ul>
          <li>Send what felt off while playing</li>
          <li>Weâ€™ll open GitHub Issues (template chooser)</li>
        </ul>
        <div class="note">
          Examples: clipped on mobile / score not increasing / laggy controls / images not loading
        </div>
      `,
      bug: "ğŸ› Report a bug",
      req: "âœ¨ Request a feature",
      fbNote: "You will be redirected to a GitHub Issue template (login required).",
      howtoHtml: `
        <h3>Basic controls</h3>
        <ul>
          <li><b>Hold</b>: Rise (keeps pushing upward)</li>
          <li><b>Release</b>: Fall (gravity)</li>
          <li><b>Tap</b>: Start / Retry</li>
        </ul>

        <h3>Modes</h3>
        <ul>
          <li><b>FLY</b>: regular flappy-style flight</li>
          <li><b>GROUND</b>: mostly crawling near the floor, short float only when â€œchargedâ€</li>
        </ul>

        <h3>Game over (the â€œbottomâ€)</h3>
        <ul>
          <li>Hit the top or bottom trees</li>
          <li><b>Touch the floor (bottom edge)</b> â†’ instant game over</li>
        </ul>

        <h3>Score</h3>
        <ul>
          <li><b>+1</b> when you pass <b>one pair</b> of trees without crashing</li>
          <li>We count it when you cross the center of the obstacle</li>
        </ul>

        <div class="note">
          Note: Tap pressure does NOT change lift on mobile.<br>
          Lift depends on how long you hold.
        </div>
      `
    }
  };

  function getSavedLang(){
    const v = localStorage.getItem('sr_lang');
    return (v === 'en' || v === 'ja') ? v : 'ja';
  }
  function saveLang(v){ localStorage.setItem('sr_lang', v); }

  function getSavedMode(){
    const v = localStorage.getItem('sr_flight_mode');
    return (v === 'ground' || v === 'fly') ? v : 'fly';
  }
  function saveMode(v){ localStorage.setItem('sr_flight_mode', v); }

  function getSavedSoundOn(){
    const v = localStorage.getItem('sr_sound_on');
    return (v === '0') ? false : true; // default ON
  }
  function saveSoundOn(on){ localStorage.setItem('sr_sound_on', on ? '1' : '0'); }

  function getSavedSoundVol(){
    const v = Number(localStorage.getItem('sr_sound_vol'));
    return Number.isFinite(v) ? Math.max(0, Math.min(1, v)) : 0.35;
  }
  function saveSoundVol(vol){ localStorage.setItem('sr_sound_vol', String(Math.max(0, Math.min(1, vol)))); }

  function getSavedDebugOn(){
    const v = localStorage.getItem('sr_debug_on');
    return v === '1';
  }
  function saveDebugOn(on){ localStorage.setItem('sr_debug_on', on ? '1' : '0'); }

  // =========================
  // Music (WebAudio, lightweight, no external files)
  // =========================
  const Music = (() => {
    let ctx = null;
    let master = null;
    let filter = null;
    let isOn = true;
    let vol = 0.35;

    let playing = false;
    let nextNoteTime = 0;
    let step = 0;
    let timerId = null;

    // vibe: gentle jp-fantasy / lo-fi-ish
    const bpm = 112;
    const stepDur = 60 / bpm / 4; // 16th
    const scheduleAhead = 0.12;
    const lookahead = 25; // ms

    // chord roots (A minor-ish)
    const chordRoots = [57, 53, 55, 52]; // A3, F3, G3, E3 (MIDI)
    const bassPattern = [0, null, null, null, 0, null, null, null, 0, null, null, null, 0, null, null, null];
    const leadPattern = [0, 2, 3, 2, 0, 2, 5, 3, 0, 2, 3, 7, 5, 3, 2, null]; // pentatonic-ish offsets
    const scale = [0, 3, 5, 7, 10, 12, 15, 17]; // A minor pentatonic-ish in semitones

    function ensure(){
      if (ctx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      ctx = new AC();
      master = ctx.createGain();
      filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 900;
      filter.Q.value = 0.7;

      master.gain.value = 0.0001;
      filter.connect(master);
      master.connect(ctx.destination);
      applyVol();
    }

    function midiToHz(m){ return 440 * Math.pow(2, (m - 69) / 12); }

    function playTone(freq, t0, dur, type, gain, detune=0){
      if (!ctx) return;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      if (detune) o.detune.setValueAtTime(detune, t0);

      // simple envelope
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(Math.max(0.0002, gain), t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      o.connect(g);
      g.connect(filter);

      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }

    function playHat(t0){
      if (!ctx) return;
      const bufferSize = 2 * ctx.sampleRate;
      const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const output = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;

      const noise = ctx.createBufferSource();
      noise.buffer = noiseBuffer;

      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 6000;

      const g = ctx.createGain();
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.03, t0 + 0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.03);

      noise.connect(hp);
      hp.connect(g);
      g.connect(filter);

      noise.start(t0);
      noise.stop(t0 + 0.04);
    }

    function schedule(){
      if (!ctx || !playing) return;
      while (nextNoteTime < ctx.currentTime + scheduleAhead){
        const bar = Math.floor(step / 16);
        const chord = chordRoots[bar % chordRoots.length];

        // bass on quarter notes (step 0,4,8,12)
        const bp = bassPattern[step % 16];
        if (bp !== null){
          playTone(midiToHz(chord + 0), nextNoteTime, 0.20, 'triangle', 0.06);
        }

        // lead on selected 16ths
        const lp = leadPattern[step % 16];
        if (lp !== null){
          const note = chord + scale[Math.min(scale.length-1, lp)];
          playTone(midiToHz(note + 12), nextNoteTime, 0.12, 'sine', 0.035, (step%2===0)? -6 : 6);
        }

        // hats on offbeats
        if ((step % 4) === 2) playHat(nextNoteTime);

        step++;
        nextNoteTime += stepDur;
      }
    }

    function start(){
      ensure();
      if (!ctx) return;
      if (!isOn) return;

      if (ctx.state === 'suspended') ctx.resume();

      if (playing) return;
      playing = true;
      step = 0;
      nextNoteTime = ctx.currentTime + 0.05;
      timerId = setInterval(schedule, lookahead);
      // fade in
      master.gain.cancelScheduledValues(ctx.currentTime);
      master.gain.setValueAtTime(master.gain.value, ctx.currentTime);
      master.gain.exponentialRampToValueAtTime(Math.max(0.0002, vol), ctx.currentTime + 0.25);
    }

    function stop(){
      if (!ctx || !playing) return;
      playing = false;
      if (timerId) { clearInterval(timerId); timerId = null; }
      // fade out
      master.gain.cancelScheduledValues(ctx.currentTime);
      master.gain.setValueAtTime(Math.max(0.0002, master.gain.value), ctx.currentTime);
      master.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.20);
    }

    function applyVol(){
      if (!ctx || !master) return;
      master.gain.cancelScheduledValues(ctx.currentTime);
      const target = isOn ? Math.max(0.0002, vol) : 0.0001;
      master.gain.setValueAtTime(Math.max(0.0001, master.gain.value), ctx.currentTime);
      master.gain.exponentialRampToValueAtTime(target, ctx.currentTime + 0.12);
    }

    function setOn(v){ isOn = !!v; applyVol(); if (!isOn) stop(); }
    function setVol(v){ vol = Math.max(0, Math.min(1, Number(v)||0)); applyVol(); }

    function userGesture(){
      ensure();
      if (ctx && ctx.state === 'suspended') ctx.resume();
    }

    return { start, stop, setOn, setVol, userGesture, _ctxState: ()=> ctx?ctx.state:'none' };
  })();


  let LANG = getSavedLang();
  function t(){ return I18N[LANG]; }

  // =========================
  // GameOver lines (humor + next move) with rare tier
  // =========================
  // Each entry: { quip: "...", next: "..." }
  const GAMEOVER_LINES = {
    ja: {
      common: [
        { quip:"â€¦â€¦ä»Šã®ã€ã¡ã‚‡ã£ã¨æ¬²å¼µã£ãŸã‚ˆã­ã€‚", next:"ä¸€æ‹ãŠã„ã¦ã€çŸ­ãæŠ¼ãã†ã€‚" },
        { quip:"ãƒ–ãƒ¼ä¹‹åŠ©ã€é£›ã°ãªã„ã¤ã‚‚ã‚Šã ã£ãŸã‚‰ã—ã„ã€‚", next:"ä¸€åº¦ã ã‘ã€æ€ã„åˆ‡ã£ã¦ã€‚" },
        { quip:"ç©ºã¯åºƒã„ã‘ã©ã€ä»Šæ—¥ã¯ä½ã‚ã ã£ãŸã€‚", next:"ä¸‹ã‹ã‚‰æŠœã‘ã‚‹æ„è­˜ã§ã€‚" },
        { quip:"ä»Šã®ã¯é£›è¡Œã¨ã„ã†ã‚ˆã‚Šã€è¦šæ‚Ÿã ã£ãŸã€‚", next:"åˆ»ã‚“ã§ã€æ§˜å­è¦‹ã€‚" },
        { quip:"ãƒ–ãƒ¼ä¹‹åŠ©ã€è€ƒãˆã™ãã¦åœ°é¢ã‚’é¸ã‚“ã ã€‚", next:"è¿·ã£ãŸã‚‰ã€è»½ãä¸€å›ã€‚" },
        { quip:"é£›ã¶å‰ã«ã€äººç”Ÿã‚’è€ƒãˆã¦ã—ã¾ã£ãŸã€‚", next:"è€ƒãˆãšã«ã€å…ˆã«æŠ¼ã™ã€‚" },
        { quip:"é£›ã°ãªã„é¸æŠã‚‚ã€ã²ã¨ã¤ã®é“ã€‚", next:"ã§ã‚‚æ¬¡ã¯ã€å°‘ã—ã ã‘ä¸Šã¸ã€‚" },
        { quip:"æ…é‡ã™ãã‚‹ã¨ã€é“ã¯ç‹­ããªã‚‹ã€‚", next:"æ—©ã‚ã«ä¸€åº¦ã€æŠ¼ã™ã€‚" },
        { quip:"ç©ºã‚’è¦‹ã™ããŸçµæœã€è¶³å…ƒã‚’å¿˜ã‚ŒãŸã€‚", next:"ä¸‹ã‚’è¦‹ã¦ã€ä½ãé€šã‚ã†ã€‚" },
        { quip:"â€¦â€¦ä»Šæ—¥ã¯ã€åœ°é¢ã¨ä»²è‰¯ããªã£ãŸã€‚", next:"æ¬¡ã¯ã€ã»ã©ã»ã©ã«ã€‚" }
      ],
      rare: [
        { quip:"ä¼èª¬ï¼šã„ã¾ã®è½ä¸‹ã€èŠ¸è¡“ç‚¹ãŒé«˜ã„ã€‚", next:"åŒã˜æ‰‹ã‚’ã€ã‚‚ã†ä¸€å›ã ã‘â€œä¸å¯§ã«â€ã‚„ã‚ã†ã€‚" },
        { quip:"ãƒ–ãƒ¼ä¹‹åŠ©ã€Œã‚„ã£ãŸã€‚ã‚„ã£ã¦ãªã„ã‘ã©ã€ã‚„ã£ãŸã€", next:"â€œæŠ¼ã•ãªã„å‹‡æ°—â€ã‚’3ç§’ã ã‘è©¦ãã†ã€‚" },
        { quip:"ç©ºã€Œæ¥ã„ã€ï¼ãƒ–ãƒ¼ä¹‹åŠ©ã€Œä»Šæ—¥ã¯ã‚„ã‚ã¨ãã€", next:"é£›ã¶æ°—é…ã ã‘è¦‹ã›ã¦ã€å¼•ãè¿”ãã†ã€‚" }
      ],
      rareChance: 0.10 // 10%
    },
    en: {
      common: [
        { quip:"That was a little too ambitious.", next:"Pause, then short taps." },
        { quip:"Bunosuke chose the ground today.", next:"One bold tap â€” just once." },
        { quip:"The sky is wide, but today was low.", next:"Take the lower path." },
        { quip:"That wasnâ€™t flight. That was commitment.", next:"Tap in small steps." },
        { quip:"He overthought it â€” and picked the floor.", next:"If unsure, one light tap." },
        { quip:"He started thinking about lifeâ€¦ mid-air.", next:"Donâ€™t think. Tap first." },
        { quip:"Not flying is also a route.", next:"Next time, just a little higher." },
        { quip:"Too careful makes the road narrower.", next:"Tap earlier â€” once." },
        { quip:"He stared at the sky and forgot his feet.", next:"Stay low and slip through." },
        { quip:"Today, he made friends with the ground.", next:"Next time: moderation." }
      ],
      rare: [
        { quip:"Legend: that fall had style points.", next:"Repeat it â€” but slower and cleaner." },
        { quip:"Bunosuke: â€œI did it.â€ (He didnâ€™t.)", next:"Try 3 seconds of courage â€” donâ€™t tap." },
        { quip:"Sky: â€œCome.â€ / Bunosuke: â€œNot today.â€", next:"Show the intent to fly, then retreat." }
      ],
      rareChance: 0.10
    }
  };

  function pickGameOverLine(){
    const pool = GAMEOVER_LINES[LANG] || GAMEOVER_LINES.ja;
    const useRare = Math.random() < pool.rareChance;
    const arr = useRare ? pool.rare : pool.common;
    const idx = Math.floor(Math.random() * arr.length);
    return { ...arr[idx], isRare: useRare };
  }

  // =========================
  // Canvas setup
  // =========================
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    const cssW = window.innerWidth > 480 ? 480 : Math.max(260, window.innerWidth - 20);
    const cssH = window.innerHeight > 640 ? 640 : Math.max(380, window.innerHeight - 20);
    const dpr = window.devicePixelRatio || 1;

    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return { w: cssW, h: cssH };
  }

  let { w: W, h: H } = resizeCanvas();
  let frames = 0, score = 0, gameState = 'START', gameSpeed = 3;

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  // =========================
  // DOM refs
  // =========================
  const hudScore = document.getElementById('hudScore');
  const hudAiMsg = document.getElementById('hudAiMsg');
  const hudStats = document.getElementById('hudStats');
  const hintLine = document.getElementById('hintLine');

  const drawer = document.getElementById('drawer');
  const btnMenu = document.getElementById('btnMenu');
  const btnClose = document.getElementById('btnClose');

  const tabLevel = document.getElementById('tabLevel');
  const tabHowto = document.getElementById('tabHowto');
  const tabFeedback = document.getElementById('tabFeedback');
  const tabLang = document.getElementById('tabLang');

  const lblMode = document.getElementById('lblMode');
  const lblPreset = document.getElementById('lblPreset');
  const lblSpeed = document.getElementById('lblSpeed');
  const lblGap = document.getElementById('lblGap');
  const lblSpawn = document.getElementById('lblSpawn');
  const lblAccel = document.getElementById('lblAccel');
  const lblSound = document.getElementById('lblSound');
  const lblVol = document.getElementById('lblVol');
  const lblLang = document.getElementById('lblLang');
  const langNote = document.getElementById('langNote');

  const howtoBox = document.getElementById('howtoBox');
  const feedbackText = document.getElementById('feedbackText');
  const fbNote = document.getElementById('fbNote');

  const langSel = document.getElementById('langSel');
  const btnBug = document.getElementById('btnBug');
  const btnReq = document.getElementById('btnReq');

  btnBug.addEventListener('click', ()=> window.open(ISSUE_URL, '_blank', 'noopener,noreferrer'));
  btnReq.addEventListener('click', ()=> window.open(ISSUE_URL, '_blank', 'noopener,noreferrer'));

  // Drawer behavior
  btnMenu.addEventListener('click', ()=> drawer.classList.add('open'));
  btnClose.addEventListener('click', ()=> drawer.classList.remove('open'));
  document.querySelectorAll('.tab').forEach(tbtn=>{
    tbtn.addEventListener('click', ()=>{
      document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
      tbtn.classList.add('active');
      const pane = tbtn.dataset.pane;
      document.querySelectorAll('.drawerBody').forEach(p=>p.classList.remove('active'));
      document.getElementById(pane).classList.add('active');
    });
  });

  // =========================
  // Difficulty
  // =========================
  const difficulty = { preset:'normal', speedBase:3.0, gapBase:200, spawnEvery:115, accelEvery:650 };
  let pendingDifficulty = { ...difficulty };

  const PRESETS = {
    easy:   { speedBase: 2.6, gapBase: 220, spawnEvery: 130, accelEvery: 720 },
    normal: { speedBase: 3.0, gapBase: 200, spawnEvery: 115, accelEvery: 650 },
    hard:   { speedBase: 3.6, gapBase: 170, spawnEvery:  98, accelEvery: 520 }
  };
  const applyDifficultyNow = ()=>Object.assign(difficulty, pendingDifficulty);

  const $ = (id)=>document.getElementById(id);
  const flightModeEl = $('flightMode');
  const presetEl=$('preset'), speedBaseEl=$('speedBase'), gapBaseEl=$('gapBase'), spawnEveryEl=$('spawnEvery'), accelEveryEl=$('accelEvery');
  const speedBaseVal=$('speedBaseVal'), gapBaseVal=$('gapBaseVal'), spawnEveryVal=$('spawnEveryVal'), accelEveryVal=$('accelEveryVal');
  const soundToggleEl = $('soundToggle');
  const soundVolEl = $('soundVol');
  const soundVolVal = $('soundVolVal');
  const debugToggleEl = $('debugToggle');
  const btnApply=$('btnApply'), btnRestart=$('btnRestart');

  function syncVals(){
    speedBaseVal.textContent = Number(speedBaseEl.value).toFixed(1);
    gapBaseVal.textContent = String(gapBaseEl.value);
    spawnEveryVal.textContent = String(spawnEveryEl.value);
    accelEveryVal.textContent = String(accelEveryEl.value);
    if (soundVolVal) soundVolVal.textContent = Number(soundVolEl.value).toFixed(2);
  }
  function setControlsFrom(obj){
    speedBaseEl.value=obj.speedBase; gapBaseEl.value=obj.gapBase; spawnEveryEl.value=obj.spawnEvery; accelEveryEl.value=obj.accelEvery;
    syncVals();
  }
  presetEl.addEventListener('change', ()=>{
    const p=presetEl.value;
    if(p!=='custom') setControlsFrom(PRESETS[p]);
  });
  [speedBaseEl,gapBaseEl,spawnEveryEl,accelEveryEl].forEach(el=>{
    el.addEventListener('input', ()=>{ presetEl.value='custom'; syncVals(); });
  });

  let FLIGHT_MODE = getSavedMode(); // 'fly' | 'ground'

  // dev settings
  let DEBUG_ON = getSavedDebugOn();

  // sound settings
  let SOUND_ON = getSavedSoundOn();
  let SOUND_VOL = getSavedSoundVol();
  flightModeEl.value = FLIGHT_MODE;
  flightModeEl.addEventListener('change', ()=>{
    FLIGHT_MODE = flightModeEl.value;
    saveMode(FLIGHT_MODE);
    setAiMsgForMode();
    updateHud();
  });

  // Debug UI
  if (debugToggleEl){
    debugToggleEl.value = DEBUG_ON ? 'on' : 'off';
    debugToggleEl.addEventListener('change', ()=>{
      DEBUG_ON = (debugToggleEl.value === 'on');
      saveDebugOn(DEBUG_ON);
      updateHud();
    });
  }

  // Sound UI
  soundToggleEl.value = SOUND_ON ? 'on' : 'off';
  soundVolEl.value = SOUND_VOL.toFixed(2);
  syncVals();

  soundToggleEl.addEventListener('change', ()=>{
    SOUND_ON = (soundToggleEl.value === 'on');
    saveSoundOn(SOUND_ON);
    Music.setOn(SOUND_ON);
    // if turning on during play, start immediately
    if (SOUND_ON && gameState === 'PLAYING') Music.start();
  });

  soundVolEl.addEventListener('input', ()=>{
    SOUND_VOL = Number(soundVolEl.value);
    saveSoundVol(SOUND_VOL);
    syncVals();
    Music.setVol(SOUND_VOL);
  });

  // apply initial sound state
  Music.setOn(SOUND_ON);
  Music.setVol(SOUND_VOL);

  btnApply.addEventListener('click', ()=>{
    pendingDifficulty = {
      preset: presetEl.value,
      speedBase: Number(speedBaseEl.value),
      gapBase: Number(gapBaseEl.value),
      spawnEvery: Number(spawnEveryEl.value),
      accelEvery: Number(accelEveryEl.value)
    };
  });
  btnRestart.addEventListener('click', ()=>{
    pendingDifficulty = {
      preset: presetEl.value,
      speedBase: Number(speedBaseEl.value),
      gapBase: Number(gapBaseEl.value),
      spawnEvery: Number(spawnEveryEl.value),
      accelEvery: Number(accelEveryEl.value)
    };
    resetGame();
    drawer.classList.remove('open');
  });

  presetEl.value='normal';
  setControlsFrom(PRESETS.normal);
  pendingDifficulty = { preset:'normal', ...PRESETS.normal };
  applyDifficultyNow();
  gameSpeed = difficulty.speedBase;

  // =========================
  // Images
  // =========================
  const imgBody = new Image(); imgBody.src = './images/buunosuke_body.png';
  const imgProp = new Image(); imgProp.src = './images/buunosuke_propeller.png';
  let imgError = null;
  imgBody.onerror = ()=>{ imgError = "buunosuke_body.png ãŒèª­ã¿è¾¼ã‚ã¾ã›ã‚“ï¼ˆ./images/ ã‚’ç¢ºèªï¼‰"; console.error(imgError); };
  imgProp.onerror = ()=>{ imgError = "buunosuke_propeller.png ãŒèª­ã¿è¾¼ã‚ã¾ã›ã‚“ï¼ˆ./images/ ã‚’ç¢ºèªï¼‰"; console.error(imgError); };
  let imagesReady=false, loaded=0;
  [imgBody,imgProp].forEach(im=>im.onload=()=>{ if(++loaded===2) imagesReady=true; });

  // =========================
  // "AIã£ã½ã„" è‡ªå‹•èª¿æ•´ï¼ˆå£Šã‚Œãªã„æœ€å°æ§‹æˆï¼‰
  // =========================
  const ai = {
    msg: "â€¦",
    mode: "normal", // soothe | normal | hell
    passStreak: 0,
    failStreak: 0,
    // current deltas (smoothed)
    gapBoost: 0,
    speedBoost: 0,
    spawnBoost: 0,
    biasY: 0,
    // internal
    target: { gap:0, spd:0, spawn:0, biasY:0 }
  };

  function setAiMode(mode){
    ai.mode = mode;
    // ã‚ˆã—ãªã«ï¼šæ¥µç«¯ã«æŒ¯ã‚Œãªã„ç¯„å›²ã§èª¿æ•´
    if(mode === 'soothe'){
      ai.target.gap = +24;   // éš™é–“åºƒã’ã‚‹
      ai.target.spd = -0.20; // å°‘ã—é…ã
      ai.target.spawn = +10; // å‡ºç¾é–“éš”ã‚’å°‘ã—é•·ã
    } else if(mode === 'hell'){
      ai.target.gap = -18;   // éš™é–“ç‹­ã
      ai.target.spd = +0.25; // é€Ÿã
      ai.target.spawn = -8;  // å‡ºç¾é–“éš”çŸ­ã
    } else {
      ai.target.gap = 0;
      ai.target.spd = 0;
      ai.target.spawn = 0;
    }
  }
  function maybeUpdateAiMode(){
    // é€£ç¶šå¤±æ•— â†’ å„ªã—ã / é€£ç¶šæˆåŠŸ â†’ å³ã—ã
    if(ai.failStreak >= 2) setAiMode('soothe');
    else if(ai.passStreak >= 6) setAiMode('hell');
    else setAiMode('normal');
  }

  function tickAi(){
    // ç›®æ¨™å€¤ã«ã˜ã‚ã£ã¨å¯„ã›ã‚‹ï¼ˆå£Šã‚Œãªã„ï¼‰
    const k = 0.02;
    ai.gapBoost   = lerp(ai.gapBoost,   ai.target.gap,   k);
    ai.speedBoost = lerp(ai.speedBoost, ai.target.spd,   k);
    ai.spawnBoost = lerp(ai.spawnBoost, ai.target.spawn, k);
    ai.biasY      = lerp(ai.biasY,      ai.target.biasY, 0.03);

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã« â€œå°‘ã—ã ã‘â€ å¯„ã›ã‚‹ï¼ˆæ•‘æ¸ˆï¼‰
    // â€»éœ²éª¨ã«ã™ã‚‹ã¨ãƒãƒ¼ãƒˆæ„ŸãŒå‡ºã‚‹ã®ã§ã€Œã¡ã‚‡ã„æ‰‹åŠ©ã‘ã€ãƒ¬ãƒ™ãƒ«ã«ã™ã‚‹
    const buuCy = buunosuke.y + buunosuke.height/2;
    const centerY = H/2;
    const desire = clamp((buuCy - centerY) * 0.15, -40, 40);
    // fail streak ãŒå¤šã„æ™‚ã ã‘å¯„ã›ã‚‹
    const help = clamp(ai.failStreak / 3, 0, 1);
    ai.target.biasY = desire * help;
  }

  function setAiMsgForMode(){
    // HUDã¯ "AI: " ã‚’ä»˜ã‘ã‚‹ã®ã§ã€ã“ã“ã¯çŸ­ã
    let modeText;
    if (LANG === 'ja'){
      modeText = (ai.mode==='soothe') ? "ç™’ã—ï¼ˆå°‘ã—å„ªã—ãï¼‰"
              : (ai.mode==='hell')   ? "åœ°ç„ï¼ˆå®¹èµ¦ãªã—ï¼‰"
              : "æ™®é€šï¼ˆ^^ï¼‰";
      ai.msg = (FLIGHT_MODE==='ground')
        ? `GROUND / ${modeText}`
        : `${modeText}`;
    } else {
      modeText = (ai.mode==='soothe') ? "Soothe (easier)"
              : (ai.mode==='hell')   ? "Hell (harder)"
              : "Normal (auto)";
      ai.msg = (FLIGHT_MODE==='ground')
        ? `GROUND / ${modeText}`
        : `${modeText}`;
    }
  }

  // =========================
  // GameOver display content (2 lines only)
  // =========================
  let goQuip = "";
  let goNext = "";
  let goIsRare = false;

  function buildGameOverLine(){
    const picked = pickGameOverLine();
    goQuip = picked.quip;
    goNext = picked.next;
    goIsRare = !!picked.isRare;
  }

  function onFail(){
    ai.failStreak++;
    ai.passStreak = 0;
    maybeUpdateAiMode();
    setAiMsgForMode();
  }
  function onPass(){
    ai.passStreak++;
    ai.failStreak = 0;
    maybeUpdateAiMode();
    setAiMsgForMode();
  }

  // =========================
  // +1 popup
  // =========================
  const popups=[];
  function addPopup(text,x,y){ popups.push({text,x,y,life:40}); }
  function drawPopups(){
    for(let i=0;i<popups.length;i++){
      const p=popups[i]; p.life--; p.y-=0.6;
      ctx.save();
      ctx.globalAlpha=clamp(p.life/40,0,1);
      ctx.fillStyle='#fff'; ctx.font='14px Arial';
      ctx.fillText(p.text,p.x,p.y);
      ctx.restore();
      if(p.life<=0){ popups.splice(i,1); i--; }
    }
  }

  // =========================
  // Player physics with mode switch
  // =========================
  const buunosuke = {
    x:60, y:H/2, width:56, height:56,
    velocity:0,
    isFlying:false,

    propOffsetX:28, propOffsetY:8, propSize:20,

    // GROUND helpers
    charge:0,
    burstFrames:0,
    lastPressFrames:0,

    applyModeParams(){
      if (FLIGHT_MODE==='ground'){
        this.gravity = 0.42;
        this.thrust = -0.18;
        this.maxUp = -2.0;
        this.maxDown = 7.0;
        this.floorStickY = 0.78;
      } else {
        this.gravity = 0.28;
        this.thrust = -0.35;
        this.maxUp = -4.6;
        this.maxDown = 6.5;
        this.floorStickY = 0.0;
      }
    },

    update(){
      if(gameState!=='PLAYING') return;

      const inGround = (FLIGHT_MODE==='ground');

      if (inGround){
        const yNorm = (this.y + this.height/2)/Math.max(1,H);
        const nearGround = yNorm > this.floorStickY;

        if (this.isFlying) this.lastPressFrames++;
        else this.lastPressFrames = 0;

        if (this.isFlying && nearGround && this.burstFrames<=0){
          this.charge = clamp(this.charge + 0.015, 0, 1);
        } else {
          this.charge = clamp(this.charge - 0.004, 0, 1);
        }

        if (this.charge >= 1 && this.burstFrames<=0){
          this.burstFrames = 55;
          this.charge = 0;
        }

        let g = this.gravity;
        let t = this.thrust;
        let maxUp = this.maxUp;

        if (this.burstFrames>0){
          this.burstFrames--;
          g = 0.22;
          t = -0.30;
          maxUp = -3.4;
        }

        this.velocity += (this.isFlying ? t : g);

        // anti-spam: long hold gets punished
        if (this.isFlying && this.lastPressFrames > 24){
          this.velocity += 0.06;
        }

        this.velocity = clamp(this.velocity, maxUp, this.maxDown);
        this.y += this.velocity;

        // ground stick
        const floorZone = H * 0.80;
        if (this.y + this.height > floorZone){
          if (this.velocity > 0) this.velocity *= 0.86;
          this.y = Math.min(this.y, H - this.height);
        }
      } else {
        this.velocity += (this.isFlying ? this.thrust : this.gravity);
        this.velocity = clamp(this.velocity, this.maxUp, this.maxDown);
        this.y += this.velocity;
      }

      // ceiling
      if(this.y < 0){ this.y = 0; this.velocity = 0; }

      // floor => game over
      if(this.y + this.height > H){
        this.y = H - this.height;
        gameState='GAMEOVER';
        Music.stop();
        buildGameOverLine();
        onFail();
      }
    },

    draw(){
      if(!imagesReady) return;
      const tilt = clamp(this.velocity*0.02, -0.10, 0.14);
      const spin = 0.25 + Math.abs(this.velocity)*0.12;
      const px = this.x + this.propOffsetX;
      const py = this.y + this.propOffsetY;

      ctx.save();
      ctx.translate(this.x+this.width/2, this.y+this.height/2);
      ctx.rotate(tilt);
      ctx.translate(-(this.x+this.width/2), -(this.y+this.height/2));

      if (imagesReady) {
      ctx.drawImage(imgBody, this.x, this.y, this.width, this.height);
    } else {
      // placeholder (so you can still play even if images missing)
      ctx.fillStyle = '#fff';
      ctx.fillRect(this.x, this.y, this.width, this.height);
    }

      ctx.save();
      ctx.translate(px,py);
      ctx.rotate(frames*spin);
      if (imagesReady) {
        ctx.drawImage(imgProp, -this.propSize/2, -this.propSize/2, this.propSize, this.propSize);
      }
      ctx.restore();

      // charge meter in GROUND
      if (FLIGHT_MODE==='ground'){
        const barW=48, barH=6;
        const bx=this.x + (this.width-barW)/2;
        const by=this.y - 10;
        ctx.globalAlpha = 0.75;
        ctx.fillStyle = 'rgba(255,255,255,0.25)';
        ctx.fillRect(bx, by, barW, barH);
        ctx.fillStyle = 'rgba(255,105,180,0.85)';
        ctx.fillRect(bx, by, barW * this.charge, barH);
        ctx.globalAlpha = 1.0;
      }

      ctx.restore();
    }
  };

  // =========================
  // Obstacles / scoring
  // =========================
  const pipes=[];
  function handleObstacles(){
    if(gameState!=='PLAYING') return;

    // AI auto-tune (applied here only; keep physics independent)
    tickAi();

    const effSpeed = clamp(gameSpeed + ai.speedBoost, 2.0, 8.0);
    const baseGap = difficulty.gapBase + ai.gapBoost;
    const gapHeight = clamp(baseGap - (effSpeed - difficulty.speedBase)*6, 120, 300);
    const spawnEvery = clamp(difficulty.spawnEvery + ai.spawnBoost, 70, 180);
    const spawnEveryInt = Math.max(1, Math.round(spawnEvery));

    if(frames % spawnEveryInt === 0){
      const margin=34;
      let gapTop = Math.random()*(H-gapHeight-margin*2)+margin;
      gapTop = clamp(gapTop + ai.biasY, margin, H-gapHeight-margin);
      pipes.push({x:W,w:54,gapTop,gapHeight,passed:false});
    }

    for(let i=0;i<pipes.length;i++){
      const p=pipes[i];
      p.x -= effSpeed;

      ctx.fillStyle='#551a1a';
      ctx.fillRect(p.x,0,p.w,p.gapTop);
      ctx.fillRect(p.x,p.gapTop+p.gapHeight,p.w,H-(p.gapTop+p.gapHeight));

      const overlapX = (buunosuke.x < p.x+p.w) && (buunosuke.x+buunosuke.width > p.x);
      const hitTop = overlapX && (buunosuke.y < p.gapTop);
      const hitBottom = overlapX && (buunosuke.y+buunosuke.height > p.gapTop+p.gapHeight);
      if(hitTop || hitBottom){
        gameState='GAMEOVER';
        Music.stop();
        buildGameOverLine();
        onFail();
      }

      // score when crossing center
      const buuCenterX = buunosuke.x + buunosuke.width/2;
      const pipeCenterX = p.x + p.w/2;
      if(!p.passed && buuCenterX > pipeCenterX){
        p.passed=true;
        score++;
        addPopup("+1", buunosuke.x+20, buunosuke.y-6);
        onPass();
      }

      if(p.x+p.w<0){ pipes.splice(i,1); i--; }
    }
  }

  // =========================
  // Background
  // =========================
  function drawBackground(){
    const g=ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,"#0a0a2a"); g.addColorStop(1,"#2a0a1a");
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    ctx.fillStyle='#ffb7c5';
    for(let i=0;i<20;i++){
      const x=(frames*2 + i*50)%W;
      const y=(Math.sin(frames/50+i)*H/2)+H/2;
      ctx.beginPath(); ctx.arc(x,y,(i%3)+2,0,Math.PI*2); ctx.fill();
    }
  }

  // =========================
  // HUD update
  // =========================
  const stats = { emaPress:0.0 };
  function updateHud(){
    stats.emaPress = lerp(stats.emaPress, buunosuke.isFlying ? 1 : 0, 0.05);
    const pressPct = Math.round(stats.emaPress*100);

    hudScore.textContent = `${t().score}: ${score}`;
    hudAiMsg.textContent = `${t().ai}: ${ai.msg}`;

    if (FLIGHT_MODE==='ground'){
      const ch = Math.round(buunosuke.charge*100);
      hudStats.textContent = (LANG==='ja')
        ? `æŠ¼ä¸‹ç‡â‰ˆ${pressPct}% / æºœã‚=${ch}%`
        : `holdâ‰ˆ${pressPct}% / charge=${ch}%`;
      // asset/sound diagnostics (only when something is wrong)
      if (imgError) hudStats.textContent += (LANG==='ja') ? ` / âš  ${imgError}` : ` / âš  ${imgError}`;
      // WebAudio may remain suspended until a user gesture
      try{
        if (SOUND_ON && Music && Music._ctxState && Music._ctxState()==='suspended'){
          hudStats.textContent += (LANG==='ja') ? ' / ğŸ”‡(ã‚¯ãƒªãƒƒã‚¯ã§éŸ³ON)' : ' / ğŸ”‡(click to enable sound)';
        }
      }catch(e){}

    } else {
      hudStats.textContent = (LANG==='ja')
        ? `æŠ¼ä¸‹ç‡â‰ˆ${pressPct}%`
        : `holdâ‰ˆ${pressPct}%`;
      // asset/sound diagnostics (only when something is wrong)
      if (imgError) hudStats.textContent += (LANG==='ja') ? ` / âš  ${imgError}` : ` / âš  ${imgError}`;
      // WebAudio may remain suspended until a user gesture
      try{
        if (SOUND_ON && Music && Music._ctxState && Music._ctxState()==='suspended'){
          hudStats.textContent += (LANG==='ja') ? ' / ğŸ”‡(ã‚¯ãƒªãƒƒã‚¯ã§éŸ³ON)' : ' / ğŸ”‡(click to enable sound)';
        }
      }catch(e){}

    }
  }

  // =========================
  // Wrap for GameOver
  // =========================
  function drawWrappedCentered(text, cx, y, maxWidth, lineHeight){
    let lines;
    if (LANG==='ja'){
      lines = [];
      let cur = '';
      for (const ch of text){
        const test = cur + ch;
        if (ctx.measureText(test).width <= maxWidth) cur = test;
        else { lines.push(cur); cur = ch; }
      }
      if (cur) lines.push(cur);
    } else {
      const words = text.split(' ');
      lines = [];
      let line = '';
      for (const w of words){
        const test = line ? (line + ' ' + w) : w;
        if (ctx.measureText(test).width <= maxWidth) line = test;
        else { if (line) lines.push(line); line = w; }
      }
      if (line) lines.push(line);
    }
    for (let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], cx, y + i*lineHeight);
    }
    return lines.length;
  }

  function drawUI(){
    if(gameState==='START'){
      ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.textAlign='center';
      ctx.font='24px Arial'; ctx.fillText(t().startTitle, W/2, H/2-20);
      ctx.font='16px Arial'; ctx.fillText(t().startSub, W/2, H/2+30);
      ctx.textAlign='left';
    } else if(gameState==='GAMEOVER'){
      ctx.fillStyle='rgba(0,0,0,0.70)'; ctx.fillRect(0,0,W,H);

      ctx.fillStyle='red'; ctx.textAlign='center';
      ctx.font='30px Arial'; ctx.fillText(t().gameOver, W/2, H/2-90);

      const maxW = Math.max(220, W - 50);

      // 1) quip
      let y = H/2 - 40;
      ctx.fillStyle='rgba(255,255,255,0.95)';
      ctx.font = goIsRare ? 'bold 15px Arial' : '14px Arial';
      y += drawWrappedCentered(goQuip || "â€¦", W/2, y, maxW, 18) * 18 + 12;

      // 2) next move (GPT feel)
      ctx.fillStyle='rgba(255,105,180,0.95)';
      ctx.font='bold 14px Arial';
      const nextLine = `${t().next}: ${goNext || ""}`;
      drawWrappedCentered(nextLine, W/2, y, maxW, 18);

      // retry
      ctx.fillStyle='#fff'; ctx.font='16px Arial';
      ctx.fillText(t().retry, W/2, H/2+120);
      ctx.textAlign='left';
    }
  }

  // =========================
  // Reset / loop
  // =========================
  function resetGame(){
    applyDifficultyNow();
    ({w:W,h:H}=resizeCanvas());
    buunosuke.applyModeParams();

    pipes.length=0; popups.length=0;
    score=0; frames=0;

    // manual base
    gameSpeed=difficulty.speedBase;
    gameState='PLAYING';

    // start music on play
    if (SOUND_ON) Music.start();

    // AI auto: new run resets streak so it doesn't snowball
    ai.passStreak = 0;
    ai.failStreak = 0;
    setAiMode('normal');
    ai.gapBoost = ai.speedBoost = ai.spawnBoost = ai.biasY = 0;
    ai.target.biasY = 0;

    buunosuke.y = (FLIGHT_MODE==='ground') ? (H - buunosuke.height - 8) : (H/2);
    buunosuke.velocity=0;
    buunosuke.charge=0;
    buunosuke.burstFrames=0;
    buunosuke.lastPressFrames=0;

    setAiMsgForMode();
    updateHud();
  }

  function loop(){
    ctx.clearRect(0,0,W,H);
    drawBackground();

    if(gameState==='PLAYING'){
      frames++;
      // base acceleration (manual)
      if(difficulty.accelEvery>0 && frames % difficulty.accelEvery === 0) gameSpeed += 0.5;

      // keep AI message fresh (mode can change on pass/fail)
      updateHud();
    }

    buunosuke.update();
    handleObstacles();
    buunosuke.draw();
    drawPopups();
    drawUI();

    requestAnimationFrame(loop);
  }

  // =========================
  // Input
  // =========================
  function pressStartOrFly(){
    Music.userGesture();
    if(gameState==='PLAYING') buunosuke.isFlying=true;
    else resetGame();
  }
  function releaseFly(){ buunosuke.isFlying=false; }

  canvas.addEventListener('mousedown', pressStartOrFly);
  canvas.addEventListener('mouseup', releaseFly);
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); pressStartOrFly(); }, {passive:false});
  canvas.addEventListener('touchend', (e)=>{ e.preventDefault(); releaseFly(); }, {passive:false});
  canvas.addEventListener('touchcancel', (e)=>{ e.preventDefault(); releaseFly(); }, {passive:false});

  window.addEventListener('resize', ()=>{
    ({w:W,h:H}=resizeCanvas());
    if(gameState!=='PLAYING') buunosuke.y=H/2;
  });

  // =========================
  // Language apply
  // =========================
  function applyLanguage(){
    hintLine.textContent = t().hint;

    tabLevel.textContent = t().tabLevel;
    tabHowto.textContent = t().tabHowto;
    tabFeedback.textContent = t().tabFeedback;
    tabLang.textContent = t().tabLang;
    btnClose.textContent = t().close;

    lblMode.textContent = t().mode;
    flightModeEl.options[0].textContent = t().modeFly;
    flightModeEl.options[1].textContent = t().modeGround;

    lblPreset.textContent = t().preset;
    lblSpeed.textContent = t().speed;
    lblGap.textContent = t().gap;
    lblSpawn.textContent = t().spawn;
    lblAccel.textContent = t().accel;

    lblSound.textContent = t().sound;
    // Keep ON/OFF but localize label if needed
    soundToggleEl.options[0].textContent = t().soundOn;
    soundToggleEl.options[1].textContent = t().soundOff;
    lblVol.textContent = t().vol;

    btnApply.textContent = t().apply;
    btnRestart.textContent = t().restart;

    lblLang.textContent = t().lang;
    langNote.textContent = t().langNote;

    howtoBox.innerHTML = t().howtoHtml;
    feedbackText.innerHTML = t().feedbackText;
    fbNote.textContent = t().fbNote;

    btnBug.textContent = t().bug;
    btnReq.textContent = t().req;

    setAiMsgForMode();
    updateHud();
  }

  // init lang
  langSel.value = LANG;
  langSel.addEventListener('change', ()=>{
    LANG = langSel.value;
    saveLang(LANG);
    applyLanguage();
  });

  // init mode
  flightModeEl.value = FLIGHT_MODE;

  // init difficulty UI
  syncVals();

  // initial
  buunosuke.applyModeParams();
  setAiMode('normal');
  setAiMsgForMode();
  applyLanguage();
  updateHud();
  loop();
</script>
</body>
</html>